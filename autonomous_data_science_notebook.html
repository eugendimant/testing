<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Autonomous Data Science Notebook</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f7fa;
            color: #333;
        }
        header {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            text-align: center;
        }
        h1 {
            margin: 0;
            font-size: 24px;
        }
        .container {
            padding: 20px;
            max-width: 1200px;
            margin: auto;
        }
        .section {
            margin-bottom: 30px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 20px;
        }
        .section h2 {
            margin-top: 0;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="text"], textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }
        input[type="file"] {
            border: none;
        }
        button {
            background-color: #3498db;
            color: #fff;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        .results {
            margin-top: 20px;
        }
        table {
            border-collapse: collapse;
            width: 100%;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        .chart-container {
            margin-top: 20px;
        }
        canvas {
            border: 1px solid #eee;
            background-color: #fff;
        }
        .commentary {
            white-space: pre-wrap;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <header>
        <h1>Autonomous Data Science Notebook</h1>
        <p>Generate insights from raw data without writing code. Upload your dataset below to begin exploring statistics, visualisations, tests and models automatically.</p>
        <!-- Version display and changelog toggle -->
        <div style="margin-top:10px; text-align:center;">
        <!-- Display the current version number; update this whenever features are added -->
        <span id="version-info" style="font-size:0.9em; color:#bdc3c7;">Version 2.5 – updated Jan 2026</span>
            <button id="toggleChangelog" style="margin-left:10px; font-size:0.8em;">Show Changelog</button>
        </div>
        <!-- Changelog section (hidden by default). This log summarises major improvements between releases. -->
        <div id="changelog" style="display:none; margin-top:10px; text-align:left; background-color:#ecf0f1; color:#2c3e50; padding:10px; border-radius:4px;">
            <h3 style="margin-top:0;">Changelog</h3>
            <ul style="margin-top:5px;">
                <li>Histogram binning is now fully automatic using the Freedman–Diaconis rule; users are no longer asked to choose a bin count.</li>
                <li>Added effect sizes (Cohen’s d, η², rank‑biserial correlation, ε², r² and Cramer’s V) and 95 % confidence intervals to statistical test results.</li>
                <li>Logistic regression now reports a pseudo‑R² measure alongside accuracy, precision, recall and F1‑scores.</li>
                <li>Suggestion engine has been expanded: it recommends investigations based on the strongest correlations and largest group differences across all numeric/categorical combinations. It also highlights potential modelling (regression, classification or clustering) opportunities.</li>
                <li>Improved colour palette and layout for charts and results; landing page simplified and placeholders reflect suggestions automatically.</li>
                <li>Added boxplots and group‑difference charts with 95 % confidence intervals to aid visual comparison across categories.</li>
                <li>Further improved automatic generation of visualisations and reports and reorganised the landing page with analysis goals; enhanced suggestions for hypotheses and scopes; removed unnecessary inputs like histogram bins.</li>
                <li>Numerous bug fixes and internal refactoring, ensuring all controls are responsive and analyses run reliably.</li>
                <li>Charts and plots now feature axes with tick marks and labels for improved readability, and each visualisation/table is followed by a concise interpretation summarising the key finding.</li>
            </ul>
        </div>
    </header>
    <div class="container">
        <div class="section" id="input-section">
            <h2>1. Provide your inputs</h2>
            <div class="form-group">
                <label for="csvFile" title="Upload your dataset file. Supported formats: CSV, TSV, JSON and plain text tables.">Upload dataset</label>
                <!-- Accept multiple formats: CSV, TSV, JSON, TXT -->
                <input type="file" id="csvFile" accept=".csv,.tsv,.json,.txt" title="Choose the file you wish to analyze. The file remains on your machine; it is not uploaded anywhere." />
            </div>
            <div class="form-group">
                <label for="hypothesis" title="Describe the hypothesis you wish to explore. This text will appear in your report.">Hypothesis</label>
                <input type="text" id="hypothesis" placeholder="Enter your hypothesis here" title="State the hypothesis or research question that guides your analysis." />
            </div>
            <div class="form-group">
                <label for="scope" title="Describe the scope of your analysis. This helps contextualize your results.">Scope</label>
                <textarea id="scope" rows="3" placeholder="Describe the scope of your analysis" title="Provide context such as time period, population, or constraints for your study."></textarea>
            </div>
            <div class="form-group" id="target-container" style="display:none;">
                <label for="targetSelect" title="Select a target variable for modelling. Leave blank for descriptive analysis.">Target variable (optional)</label>
                <select id="targetSelect" title="Choose a numeric or binary variable to be predicted by the modelling algorithms."></select>
            </div>

            <!-- Analysis goals: allow the user to indicate what types of analyses they are most interested in. -->
            <div class="form-group" id="analysis-goals-group" style="display:none;">
                <label title="Select the analyses you want to perform. You can leave these all checked to run a full exploratory analysis.">Analysis goals</label>
                <div style="display:flex; flex-wrap:wrap; gap:10px;">
                    <label style="display:flex; align-items:center;">
                        <input type="checkbox" id="goalDescribe" checked title="Generate summary statistics and distribution plots for your variables." />
                        <span style="margin-left:4px;">Descriptive statistics</span>
                    </label>
                    <label style="display:flex; align-items:center;">
                        <input type="checkbox" id="goalRelationship" checked title="Identify correlations between numeric variables and differences across categories." />
                        <span style="margin-left:4px;">Relationships & differences</span>
                    </label>
                    <label style="display:flex; align-items:center;">
                        <input type="checkbox" id="goalTests" checked title="Perform statistical tests (t‑test/ANOVA, non‑parametric, correlation, chi‑square)." />
                        <span style="margin-left:4px;">Statistical tests</span>
                    </label>
                    <label style="display:flex; align-items:center;">
                        <input type="checkbox" id="goalModel" checked title="Build predictive models such as regression, classification or clustering." />
                        <span style="margin-left:4px;">Predictive modelling</span>
                    </label>
                </div>
            </div>
            <!-- The Analyze Dataset button is always enabled; dataset presence is checked in code -->
            <button id="analyzeBtn" type="button" title="Load your dataset and perform automatic exploratory analysis.">Analyze Dataset</button>

            <!-- Suggestions for hypothesis and scope based on the data -->
            <div id="suggestions-section" class="form-group" style="display:none; margin-top:15px;">
                <h3>Suggestions</h3>
                <p style="margin-bottom:5px;">Based on the uploaded dataset, consider these research questions:</p>
                <ul id="hypothesisSuggestions" style="margin-top:0; margin-bottom:10px; padding-left:20px;"></ul>
                <p style="margin-bottom:5px;">Potential ways to describe the scope of your analysis:</p>
                <ul id="scopeSuggestions" style="margin-top:0; padding-left:20px;"></ul>
            </div>
        </div>

        <div class="section results" id="results-section" style="display:none;">
            <h2>2. Analysis Results</h2>
            <div id="data-preview"></div>
            <div id="overview" class="commentary"></div>
            <div id="numeric-summary"></div>
            <div id="plots"></div>
        </div>

        <!-- Additional diagnostics: duplicates and statistical tests -->
        <div class="section" id="extras-section" style="display:none;">
            <h2>3. Additional Diagnostics</h2>
            <section id="duplicates-section" style="display:none; margin-top:10px;">
                <h3>Duplicates</h3>
                <p id="duplicates-summary"></p>
                <button id="removeDuplicatesBtn" title="Remove duplicate rows from the dataset.">Remove Duplicates</button>
            </section>
            <section id="tests-section" style="display:none; margin-top:10px;">
                <h3>Statistical Tests</h3>
                <p>
                    Select a test type and the relevant variables. <strong>Difference</strong> tests compare means across categories using a t‑test or ANOVA. <strong>Non‑parametric</strong> tests assess differences between groups without assuming normality (Mann–Whitney for two groups, Kruskal–Wallis for more). <strong>Correlation</strong> tests measure the strength of association between two numeric variables using Pearson or Spearman methods. <strong>Chi‑square</strong> tests examine independence between two categorical variables.
                </p>
                <div class="form-group">
                    <label for="testTypeSelect" title="Choose the type of statistical test to run.">Test type:</label>
                    <select id="testTypeSelect" title="Select the type of statistical test (difference, non‑parametric, correlation or chi‑square).">
                        <option value="difference" selected>Difference (t‑test/ANOVA)</option>
                        <option value="nonparam">Non‑parametric (Mann‑Whitney/Kruskal‑Wallis)</option>
                        <option value="correlation">Correlation</option>
                        <option value="chi2">Chi‑square</option>
                    </select>
                </div>
                <!-- Difference test variables -->
                <div id="diff-test-opts">
                    <label for="testNumericSelect1" title="Numeric variable for difference test.">Numeric variable:</label>
                    <select id="testNumericSelect1"></select>
                    <label for="testCategoricalSelect1" title="Categorical variable defining groups.">Categorical variable:</label>
                    <select id="testCategoricalSelect1"></select>
                </div>
                <!-- Correlation test variables -->
                <div id="corr-test-opts" style="display:none;">
                    <label for="testNumericSelect2" title="First numeric variable for correlation test.">Numeric variable 1:</label>
                    <select id="testNumericSelect2"></select>
                    <label for="testNumericSelect3" title="Second numeric variable for correlation test.">Numeric variable 2:</label>
                    <select id="testNumericSelect3"></select>
                    <label for="corrTestMethod" title="Method for correlation test: Pearson (linear) or Spearman (rank).">Method:</label>
                    <select id="corrTestMethod">
                        <option value="pearson" selected>Pearson</option>
                        <option value="spearman">Spearman</option>
                    </select>
                </div>
                <!-- Chi-square test variables -->
                <div id="chi-test-opts" style="display:none;">
                    <label for="testCategoricalSelect2" title="First categorical variable for chi-square test.">Categorical variable 1:</label>
                    <select id="testCategoricalSelect2"></select>
                    <label for="testCategoricalSelect3" title="Second categorical variable for chi-square test.">Categorical variable 2:</label>
                    <select id="testCategoricalSelect3"></select>
                </div>
                <button id="runTestBtn" title="Execute the selected statistical test on the chosen variables.">Run Test</button>
                <div id="testResults" style="margin-top:10px;"></div>
            </section>
            <button id="downloadCleanedBtn" style="display:none; margin-top:10px;" title="Download the current cleaned dataset as a CSV file.">Download Cleaned Dataset</button>
        </div>
        <!-- Data cleaning section (missing values, imputation, outliers) -->
        <div class="section" id="cleaning-section" style="display:none;">
            <h2>4. Data Cleaning</h2>
            <div id="missing-values"></div>
            <div class="form-group">
                <label for="missingStrategy" title="Choose how to handle missing values. Dropping removes any row with a missing value; Mean/Median imputes numeric values and fills categorical values with the most frequent category.">Missing value handling:</label>
                <select id="missingStrategy" title="Select a strategy for handling missing values.">
                    <option value="none">None</option>
                    <option value="drop">Drop rows with missing values</option>
                    <option value="mean">Impute numeric with mean, categorical with mode</option>
                    <option value="median">Impute numeric with median, categorical with mode</option>
                </select>
                <button id="applyCleaningBtn" title="Apply the selected missing value strategy.">Apply Cleaning</button>
            </div>
            <div class="form-group">
                <label for="zThreshold" title="Set the z‑score threshold for outlier removal. Points with z‑scores above this threshold will be removed.">Outlier removal (z‑score threshold):</label>
                <input type="number" id="zThreshold" min="2" max="5" step="0.1" value="3" title="Enter a z‑score threshold between 2 and 5 for outlier removal." />
                <button id="removeOutliersBtn" title="Remove rows with outliers based on the specified z‑score threshold.">Remove Outliers</button>
            </div>
        </div>

        <!-- Modeling section -->
        <div class="section" id="modeling-section" style="display:none;">
            <h2>5. Modeling</h2>
            <div class="form-group">
                <label for="modelSelect" title="Select the algorithm to apply to your data. Regression models require a numeric target; classification models require a categorical or binary target.">Choose modeling algorithm</label>
                <select id="modelSelect" title="Choose a modelling algorithm to run.">
                    <option value="">(none)</option>
                    <option value="linear">Linear Regression</option>
                    <option value="logistic">Logistic Regression</option>
                    <option value="knn">K‑Nearest Neighbors</option>
                    <option value="kmeans">K‑means Clustering</option>
                    <option value="decisionTree">Decision Tree</option>
                </select>
                <div id="modelOptions" style="margin-top:10px;"></div>
                <!-- Feature scaling selection -->
                <label for="scalingSelect" title="Choose how numeric predictors should be scaled before modelling. Standard scales to mean 0 and variance 1; Min‑Max scales to [0,1]; None leaves values unchanged.">Feature scaling:</label>
                <select id="scalingSelect" title="Select how to scale numeric features.">
                    <option value="none" selected>None</option>
                    <option value="standard">Standard (z‑score)</option>
                    <option value="minmax">Min‑Max</option>
                </select>
                <!-- Cross-validation folds -->
                <label for="cvFolds" title="Number of cross-validation folds. Use 1 for a simple train/test split.">CV Folds:</label>
                <input type="number" id="cvFolds" value="1" min="1" max="10" style="width:50px; margin-right:5px;" title="Enter the number of cross-validation folds (1 = no cross-validation).">
                <button id="runModelBtn" title="Run the selected model using the current dataset and options.">Run Model</button>
            </div>
            <div id="modelResults" class="commentary"></div>
        </div>

        <div class="section" id="report-section" style="display:none;">
            <h2>6. Customizable Scientific Report</h2>
            <p>The report below is auto‑generated based on your dataset and analysis. You can edit it as you see fit before downloading.</p>
            <textarea id="reportArea" rows="12" style="width:100%; font-family: monospace;"></textarea>
            <br />
            <button id="downloadReportBtn" title="Download the generated report as a text file.">Download Report</button>
        </div>

        <!-- History section: records all actions performed during the session -->
        <div class="section" id="history-section" style="display:none;">
            <h2>7. History log</h2>
            <p>This log records every operation you perform on the current dataset. You can use it to reproduce or audit your analysis later.</p>
            <table id="historyTable" style="width:100%; border-collapse:collapse;"></table>
            <button id="downloadHistoryBtn" style="margin-top:10px;" title="Download the history log as a CSV file for reproducibility.">Download History</button>
        </div>
    </div>
    <script>

        // Define a palette of distinctive colors for charts. These colours are rotated when plotting multiple variables.
        // Colour palette inspired by colourblind‑friendly palettes (Tableau 10) for improved distinction
        const colorPalette = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];

        // Utility functions for parsing and statistics
        // Parse delimited text (CSV/TSV) with a specified delimiter
        function parseTable(text, delim) {
            const lines = text.trim().split(/\r?\n/);
            const headers = lines[0].split(delim).map(h => h.trim());
            const rows = [];
            for (let i = 1; i < lines.length; i++) {
                const cells = lines[i].split(delim);
                // Skip empty lines
                if (cells.length === 1 && cells[0].trim() === '') continue;
                // Pad cells to headers length
                while (cells.length < headers.length) cells.push('');
                const obj = {};
                for (let j = 0; j < headers.length; j++) {
                    const val = cells[j] ? cells[j].trim() : '';
                    obj[headers[j]] = val === '' ? null : val;
                }
                rows.push(obj);
            }
            return { headers, rows };
        }

        // Determine file type and parse accordingly
        function parseData(fileName, text) {
            const parts = fileName.split('.');
            const ext = parts.length > 1 ? parts.pop().toLowerCase() : '';
            if (ext === 'json') {
                try {
                    const json = JSON.parse(text);
                    if (Array.isArray(json) && json.length > 0 && typeof json[0] === 'object') {
                        const headers = Object.keys(json[0]);
                        const rows = json.map(obj => {
                            // Ensure all headers present
                            const row = {};
                            headers.forEach(h => { row[h] = obj[h] !== undefined ? obj[h] : null; });
                            return row;
                        });
                        return { headers, rows };
                    }
                    alert('JSON file must contain an array of objects.');
                    return null;
                } catch (err) {
                    alert('Failed to parse JSON: ' + err.message);
                    return null;
                }
            } else {
                // Determine delimiter: TSV for .tsv or if tabs outnumber commas
                let delim = ',';
                if (ext === 'tsv') {
                    delim = '\t';
                } else {
                    // simple heuristic: use tab if more tabs than commas in header line
                    const firstLine = text.split(/\r?\n/)[0];
                    const commaCount = (firstLine.match(/,/g) || []).length;
                    const tabCount = (firstLine.match(/\t/g) || []).length;
                    if (tabCount > commaCount) delim = '\t';
                }
                return parseTable(text, delim);
            }
        }

        function isNumericColumn(values) {
            // Determine whether at least 90% of values can be parsed as numbers
            let numericCount = 0;
            const total = values.length;
            for (const val of values) {
                const num = parseFloat(val);
                if (!isNaN(num)) numericCount++;
            }
            return numericCount / total >= 0.9;
        }

        function computeStats(values) {
            // Convert to numeric values ignoring NaNs
            const nums = values.map(v => parseFloat(v)).filter(v => !isNaN(v));
            const n = nums.length;
            const mean = nums.reduce((a, b) => a + b, 0) / n;
            const sorted = nums.slice().sort((a, b) => a - b);
            const median = sorted[Math.floor(n / 2)];
            const min = sorted[0];
            const max = sorted[n - 1];
            const variance = nums.reduce((sum, x) => sum + Math.pow(x - mean, 2), 0) / (n - 1);
            const std = Math.sqrt(variance);
            return { mean, median, min, max, std };
        }

        function computeCorrelation(x, y) {
            const xs = x.map(v => parseFloat(v)).filter(v => !isNaN(v));
            const ys = y.map(v => parseFloat(v)).filter(v => !isNaN(v));
            const n = Math.min(xs.length, ys.length);
            if (n === 0) return 0;
            const meanX = xs.reduce((a, b) => a + b, 0) / n;
            const meanY = ys.reduce((a, b) => a + b, 0) / n;
            let num = 0, denX = 0, denY = 0;
            for (let i = 0; i < n; i++) {
                const dx = xs[i] - meanX;
                const dy = ys[i] - meanY;
                num += dx * dy;
                denX += dx * dx;
                denY += dy * dy;
            }
            return num / Math.sqrt(denX * denY);
        }

        // Compute rank array for Spearman correlation (handles ties with average rank)
        function rankArray(arr) {
            const sorted = arr.map((val, idx) => ({ val, idx })).sort((a, b) => a.val - b.val);
            const ranks = new Array(arr.length);
            let rank = 1;
            for (let i = 0; i < sorted.length; i++) {
                let j = i;
                while (j < sorted.length && sorted[j].val === sorted[i].val) j++;
                const avgRank = (rank + (rank + (j - i) - 1)) / 2;
                for (let k = i; k < j; k++) {
                    ranks[sorted[k].idx] = avgRank;
                }
                rank += (j - i);
                i = j - 1;
            }
            return ranks;
        }

        // Compute Spearman correlation by ranking the values and computing Pearson on ranks
        function computeSpearmanCorrelation(x, y) {
            // Collect pairs of numeric values (exclude NaNs on either axis)
            const pairs = [];
            for (let i = 0; i < x.length; i++) {
                const xi = parseFloat(x[i]);
                const yi = parseFloat(y[i]);
                if (!isNaN(xi) && !isNaN(yi)) {
                    pairs.push({ x: xi, y: yi });
                }
            }
            if (pairs.length === 0) return 0;
            const xs = pairs.map(p => p.x);
            const ys = pairs.map(p => p.y);
            const rx = rankArray(xs);
            const ry = rankArray(ys);
            return computeCorrelation(rx, ry);
        }

        // Compute scaling statistics (means, stds, mins, maxs) for a set of predictors across the current dataset
        function computeScalingStats(predictors) {
            const means = [];
            const stds = [];
            const mins = [];
            const maxs = [];
            predictors.forEach((p, idx) => {
                const vals = currentRows.map(r => parseFloat(r[p]) || 0);
                const n = vals.length;
                const sum = vals.reduce((a, b) => a + b, 0);
                const mean = sum / (n || 1);
                let variance = 0;
                let minVal = Infinity;
                let maxVal = -Infinity;
                vals.forEach(v => {
                    variance += Math.pow(v - mean, 2);
                    if (v < minVal) minVal = v;
                    if (v > maxVal) maxVal = v;
                });
                const std = Math.sqrt(variance / ((n > 1) ? (n - 1) : 1));
                means[idx] = mean;
                stds[idx] = std;
                mins[idx] = minVal;
                maxs[idx] = maxVal;
            });
            return { means, stds, mins, maxs };
        }

        // Scale a row of predictor values according to selected scaling method and precomputed stats
        function scalePredictorValues(row, predictors, scalingStats, method) {
            const arr = [];
            predictors.forEach((p, idx) => {
                let val = parseFloat(row[p]);
                if (isNaN(val)) val = 0;
                if (method === 'standard') {
                    const std = scalingStats.stds[idx] || 1;
                    arr.push((val - scalingStats.means[idx]) / std);
                } else if (method === 'minmax') {
                    const range = scalingStats.maxs[idx] - scalingStats.mins[idx];
                    arr.push(range !== 0 ? (val - scalingStats.mins[idx]) / range : 0);
                } else {
                    // no scaling
                    arr.push(val);
                }
            });
            return arr;
        }

        // Color scale for correlation values (from blue to red)
        function correlationColor(value) {
            // Map [-1,1] to [0,1]
            const t = (value + 1) / 2;
            // Interpolate between blue (#2166ac) and white (#ffffff) and red (#b2182b)
            // We'll use two ranges: [0,0.5] blue->white; [0.5,1] white->red
            function hexToRgb(hex) {
                const bigint = parseInt(hex.slice(1), 16);
                return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
            }
            function rgbToHex(r,g,b){
                return '#' + [r,g,b].map(x => x.toString(16).padStart(2,'0')).join('');
            }
            const blue = hexToRgb('#2166ac');
            const white = hexToRgb('#ffffff');
            const red = hexToRgb('#b2182b');
            let r, g, b;
            if (t < 0.5) {
                const k = t / 0.5;
                r = Math.round(blue[0] + (white[0] - blue[0]) * k);
                g = Math.round(blue[1] + (white[1] - blue[1]) * k);
                b = Math.round(blue[2] + (white[2] - blue[2]) * k);
            } else {
                const k = (t - 0.5) / 0.5;
                r = Math.round(white[0] + (red[0] - white[0]) * k);
                g = Math.round(white[1] + (red[1] - white[1]) * k);
                b = Math.round(white[2] + (red[2] - white[2]) * k);
            }
            return rgbToHex(r, g, b);
        }

        // Chart drawing functions
        function drawHistogram(canvas, values, label, color, binOverride) {
            // Draw a histogram for a numeric array. Bins are determined automatically using
            // the Freedman–Diaconis rule unless a specific binOverride is provided. Adds axes and ticks.
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            ctx.clearRect(0, 0, width, height);
            const nums = values.map(v => parseFloat(v)).filter(v => !isNaN(v));
            const n = nums.length;
            if (n === 0) return;
            const minVal = Math.min(...nums);
            const maxVal = Math.max(...nums);
            // Determine bins: if binOverride is provided and valid, use it; otherwise compute
            let bins = binOverride;
            if (!bins || isNaN(bins)) {
                const sorted = nums.slice().sort((a, b) => a - b);
                const q1 = sorted[Math.floor(0.25 * (n - 1))];
                const q3 = sorted[Math.floor(0.75 * (n - 1))];
                const iqr = q3 - q1;
                const binWidthAuto = (iqr > 0 ? (2 * iqr) / Math.cbrt(n) : (maxVal - minVal) / Math.cbrt(n));
                const estBins = binWidthAuto > 0 ? Math.ceil((maxVal - minVal) / binWidthAuto) : 10;
                bins = Math.max(5, Math.min(50, estBins));
            }
            const binWidth = (maxVal - minVal) / bins;
            const counts = new Array(bins).fill(0);
            nums.forEach(val => {
                let idx = Math.floor((val - minVal) / binWidth);
                if (idx < 0) idx = 0;
                if (idx >= bins) idx = bins - 1;
                counts[idx]++;
            });
            const maxCount = Math.max(...counts);
            const leftPad = 40;
            const bottomPad = 35;
            const plotW = width - leftPad - 10;
            const plotH = height - bottomPad - 10;
            const barW = plotW / bins;
            // Draw bars
            ctx.fillStyle = color || '#3498db';
            for (let i = 0; i < bins; i++) {
                const barHeight = maxCount > 0 ? (counts[i] / maxCount) * (plotH - 10) : 0;
                const x = leftPad + i * barW;
                const y = 10 + (plotH - barHeight);
                ctx.fillRect(x + 1, y, barW - 2, barHeight);
            }
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            // y-axis
            ctx.beginPath();
            ctx.moveTo(leftPad, 10);
            ctx.lineTo(leftPad, 10 + plotH);
            ctx.stroke();
            // x-axis
            ctx.beginPath();
            ctx.moveTo(leftPad, 10 + plotH);
            ctx.lineTo(leftPad + plotW, 10 + plotH);
            ctx.stroke();
            // y-axis ticks and labels
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            const yTicks = 5;
            for (let i = 0; i <= yTicks; i++) {
                const tVal = (maxCount / yTicks) * i;
                const y = 10 + plotH - (tVal / maxCount) * (plotH - 10);
                ctx.beginPath();
                ctx.moveTo(leftPad - 4, y);
                ctx.lineTo(leftPad, y);
                ctx.stroke();
                ctx.fillText(Math.round(tVal), leftPad - 6, y);
            }
            // x-axis label
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillStyle = '#333';
            ctx.fillText(label, leftPad + plotW / 2, 10 + plotH + 20);
        }

        function drawBarChart(canvas, categories, counts, color) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            ctx.clearRect(0, 0, width, height);
            const n = categories.length;
            if (n === 0) return;
            const maxCount = Math.max(...counts);
            const leftPad = 40;
            const bottomPad = 35;
            const plotW = width - leftPad - 10;
            const plotH = height - bottomPad - 10;
            const barWidth = plotW / n;
            // Draw bars
            ctx.font = '10px sans-serif';
            for (let i = 0; i < n; i++) {
                const barHeight = maxCount > 0 ? (counts[i] / maxCount) * (plotH - 10) : 0;
                const x = leftPad + i * barWidth;
                const y = 10 + (plotH - barHeight);
                ctx.fillStyle = color || '#2ecc71';
                ctx.fillRect(x + 1, y, barWidth - 2, barHeight);
                // Draw category labels rotated if necessary
                ctx.fillStyle = '#333';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                const textX = x + barWidth / 2;
                const textY = 10 + plotH + 4;
                ctx.save();
                // Rotate labels if too many categories
                if (n > 6) {
                    ctx.translate(textX, textY);
                    ctx.rotate(-Math.PI / 4);
                    ctx.fillText(categories[i], 0, 0);
                    ctx.restore();
                } else {
                    ctx.fillText(categories[i], textX, textY);
                }
            }
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            // y-axis
            ctx.beginPath();
            ctx.moveTo(leftPad, 10);
            ctx.lineTo(leftPad, 10 + plotH);
            ctx.stroke();
            // x-axis
            ctx.beginPath();
            ctx.moveTo(leftPad, 10 + plotH);
            ctx.lineTo(leftPad + plotW, 10 + plotH);
            ctx.stroke();
            // y-axis ticks
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            const yTicks = 5;
            for (let i = 0; i <= yTicks; i++) {
                const tVal = (maxCount / yTicks) * i;
                const y = 10 + plotH - (tVal / maxCount) * (plotH - 10);
                ctx.beginPath();
                ctx.moveTo(leftPad - 4, y);
                ctx.lineTo(leftPad, y);
                ctx.stroke();
                ctx.fillText(Math.round(tVal), leftPad - 6, y);
            }
            // x-axis label (variable name) left intentionally blank since categories serve as axis labels
        }

        function drawScatter(canvas, xs, ys, xLabel, yLabel, color) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            ctx.clearRect(0, 0, width, height);
            // Convert to numeric arrays (exclude pairs with NaNs)
            const xNums = [];
            const yNums = [];
            for (let i = 0; i < xs.length; i++) {
                const xVal = parseFloat(xs[i]);
                const yVal = parseFloat(ys[i]);
                if (!isNaN(xVal) && !isNaN(yVal)) {
                    xNums.push(xVal);
                    yNums.push(yVal);
                }
            }
            const n = xNums.length;
            if (n === 0) return;
            const xMin = Math.min(...xNums);
            const xMax = Math.max(...xNums);
            const yMin = Math.min(...yNums);
            const yMax = Math.max(...yNums);
            const leftPad = 50;
            const bottomPad = 40;
            const topPad = 20;
            const rightPad = 20;
            const plotW = width - leftPad - rightPad;
            const plotH = height - topPad - bottomPad;
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            // x-axis
            ctx.beginPath();
            ctx.moveTo(leftPad, topPad + plotH);
            ctx.lineTo(leftPad + plotW, topPad + plotH);
            ctx.stroke();
            // y-axis
            ctx.beginPath();
            ctx.moveTo(leftPad, topPad);
            ctx.lineTo(leftPad, topPad + plotH);
            ctx.stroke();
            // Draw ticks (5 divisions) for axes
            ctx.font = '10px sans-serif';
            ctx.fillStyle = '#333';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            const xTicks = 5;
            for (let i = 0; i <= xTicks; i++) {
                const frac = i / xTicks;
                const x = leftPad + frac * plotW;
                ctx.beginPath();
                ctx.moveTo(x, topPad + plotH);
                ctx.lineTo(x, topPad + plotH + 4);
                ctx.stroke();
                const val = xMin + frac * (xMax - xMin);
                ctx.fillText(val.toFixed(2), x, topPad + plotH + 12);
            }
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            const yTicks = 5;
            for (let i = 0; i <= yTicks; i++) {
                const frac = i / yTicks;
                const y = topPad + plotH - frac * plotH;
                ctx.beginPath();
                ctx.moveTo(leftPad - 4, y);
                ctx.lineTo(leftPad, y);
                ctx.stroke();
                const val = yMin + frac * (yMax - yMin);
                ctx.fillText(val.toFixed(2), leftPad - 6, y);
            }
            // Draw points
            ctx.fillStyle = color || '#e74c3c';
            for (let i = 0; i < n; i++) {
                const px = (xNums[i] - xMin) / (xMax - xMin || 1);
                const py = (yNums[i] - yMin) / (yMax - yMin || 1);
                const x = leftPad + px * plotW;
                const y = topPad + plotH - py * plotH;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                ctx.fill();
            }
            // Axis labels
            ctx.fillStyle = '#333';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(xLabel, leftPad + plotW / 2, topPad + plotH + 20);
            ctx.save();
            ctx.translate(leftPad - 35, topPad + plotH / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(yLabel, 0, 0);
            ctx.restore();
        }

        function drawHeatmap(canvas, corrMatrix, labels) {
            const ctx = canvas.getContext('2d');
            const size = labels.length;
            const width = canvas.width;
            const height = canvas.height;
            ctx.clearRect(0, 0, width, height);
            const cellSize = Math.min((width - 100) / size, (height - 100) / size);
            // Draw cells
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const val = corrMatrix[i][j];
                    ctx.fillStyle = correlationColor(val);
                    const x = 50 + j * cellSize;
                    const y = 50 + i * cellSize;
                    ctx.fillRect(x, y, cellSize, cellSize);
                    ctx.fillStyle = (Math.abs(val) > 0.6) ? '#fff' : '#333';
                    ctx.font = `${Math.max(10, cellSize / 4)}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(val.toFixed(2), x + cellSize / 2, y + cellSize / 2);
                }
            }
            // Draw labels
            ctx.fillStyle = '#333';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'right';
            for (let i = 0; i < size; i++) {
                const y = 50 + i * cellSize + cellSize / 2;
                ctx.fillText(labels[i], 45, y);
            }
            ctx.textAlign = 'center';
            for (let j = 0; j < size; j++) {
                const x = 50 + j * cellSize + cellSize / 2;
                ctx.save();
                ctx.translate(x, 45);
                // Rotate labels vertically to reduce overlap
                ctx.rotate(-Math.PI / 2);
                ctx.fillText(labels[j], 0, 0);
                ctx.restore();
            }
            ctx.fillText('Correlation Matrix', width / 2, 20);
        }

        // Draw a box plot for a numeric variable. This visualises the median,
        // quartiles, whiskers and outliers to summarise the distribution. Values
        // outside 1.5×IQR are marked as outliers. Colours can be customised.
        function drawBoxPlot(canvas, values, label, color) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            ctx.clearRect(0, 0, width, height);
            const nums = values.map(v => parseFloat(v)).filter(v => !isNaN(v));
            const n = nums.length;
            if (n === 0) return;
            nums.sort((a, b) => a - b);
            // Helper to compute percentile
            function percentile(arr, p) {
                if (arr.length === 0) return NaN;
                const idx = (p / 100) * (arr.length - 1);
                const lower = Math.floor(idx);
                const upper = Math.ceil(idx);
                const weight = idx - lower;
                if (upper >= arr.length) return arr[lower];
                return arr[lower] * (1 - weight) + arr[upper] * weight;
            }
            const q1 = percentile(nums, 25);
            const median = percentile(nums, 50);
            const q3 = percentile(nums, 75);
            const iqr = q3 - q1;
            const lowerFence = q1 - 1.5 * iqr;
            const upperFence = q3 + 1.5 * iqr;
            const minVal = Math.min(...nums);
            const maxVal = Math.max(...nums);
            // Determine whiskers: the most extreme values within the fences
            let lowerWhisker = nums[0];
            let upperWhisker = nums[nums.length - 1];
            for (const v of nums) {
                if (v >= lowerFence) { lowerWhisker = v; break; }
            }
            for (let i = nums.length - 1; i >= 0; i--) {
                if (nums[i] <= upperFence) { upperWhisker = nums[i]; break; }
            }
            // Scale function to map data values to pixel positions horizontally
            const paddingLeft = 40;
            const paddingRight = 20;
            const plotWidth = width - paddingLeft - paddingRight;
            const xScale = v => {
                if (upperWhisker === lowerWhisker) return paddingLeft + plotWidth / 2;
                return paddingLeft + ( (v - lowerWhisker) / (upperWhisker - lowerWhisker) ) * plotWidth;
            };
            const boxY = height / 2;
            const boxHeight = height / 4;
            // Draw whiskers
            ctx.strokeStyle = color || '#34495e';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(xScale(lowerWhisker), boxY);
            ctx.lineTo(xScale(q1), boxY);
            ctx.moveTo(xScale(q3), boxY);
            ctx.lineTo(xScale(upperWhisker), boxY);
            ctx.stroke();
            // Draw whisker caps
            const capHeight = boxHeight / 4;
            ctx.beginPath();
            ctx.moveTo(xScale(lowerWhisker), boxY - capHeight / 2);
            ctx.lineTo(xScale(lowerWhisker), boxY + capHeight / 2);
            ctx.moveTo(xScale(upperWhisker), boxY - capHeight / 2);
            ctx.lineTo(xScale(upperWhisker), boxY + capHeight / 2);
            ctx.stroke();
            // Draw the box (from Q1 to Q3)
            ctx.fillStyle = color || '#95a5a6';
            const boxX = xScale(q1);
            const boxW = xScale(q3) - xScale(q1);
            ctx.fillRect(boxX, boxY - boxHeight / 2, boxW, boxHeight);
            // Draw median line
            ctx.strokeStyle = '#e74c3c';
            ctx.beginPath();
            ctx.moveTo(xScale(median), boxY - boxHeight / 2);
            ctx.lineTo(xScale(median), boxY + boxHeight / 2);
            ctx.stroke();
            // Plot outliers as small circles if outside whiskers
            ctx.fillStyle = '#e74c3c';
            nums.forEach(v => {
                if (v < lowerWhisker || v > upperWhisker) {
                    const px = xScale(v);
                    const py = boxY;
                    ctx.beginPath();
                    ctx.arc(px, py, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
            // Axis line
            ctx.strokeStyle = '#333';
            ctx.beginPath();
            ctx.moveTo(paddingLeft, boxY + boxHeight / 2 + 20);
            ctx.lineTo(width - paddingRight, boxY + boxHeight / 2 + 20);
            ctx.stroke();
            // Labels: variable name and min/max values
            ctx.fillStyle = '#333';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(label, width / 2, height - 5);
        }

        // Draw a bar chart with error bars representing group means and their confidence intervals.
        // labels: group names; means: array of means; ciLow, ciHigh: arrays of lower/upper CI bounds.
        // The chart uses the provided colour for bars and draws vertical error bars.
        function drawGroupedMeanChart(canvas, labels, means, ciLow, ciHigh, varName, catName, color) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            ctx.clearRect(0, 0, width, height);
            const n = labels.length;
            if (n === 0) return;
            const maxY = Math.max(...ciHigh);
            const minY = Math.min(...ciLow);
            const plotHeight = height - 50;
            const plotWidth = width - 40;
            const barWidth = plotWidth / n;
            // Scale function for Y axis
            const yScale = v => {
                return (1 - (v - minY) / (maxY - minY || 1)) * plotHeight + 20;
            };
            for (let i = 0; i < n; i++) {
                const xCenter = 20 + barWidth * i + barWidth / 2;
                // Draw bar
                ctx.fillStyle = color || '#8e44ad';
                const barHeight = yScale(means[i]);
                ctx.fillRect(xCenter - barWidth * 0.3, barHeight, barWidth * 0.6, yScale(minY) - barHeight);
                // Draw error bar
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(xCenter, yScale(ciLow[i]));
                ctx.lineTo(xCenter, yScale(ciHigh[i]));
                ctx.moveTo(xCenter - 5, yScale(ciLow[i]));
                ctx.lineTo(xCenter + 5, yScale(ciLow[i]));
                ctx.moveTo(xCenter - 5, yScale(ciHigh[i]));
                ctx.lineTo(xCenter + 5, yScale(ciHigh[i]));
                ctx.stroke();
                // Draw category label
                ctx.fillStyle = '#333';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(labels[i], xCenter, height - 10);
            }
            // Add axis label above bars
            ctx.fillStyle = '#333';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            const title = `${varName} by ${catName} (95% CI)`;
            ctx.fillText(title, width / 2, 15);
        }

        // ======== Summary and interpretation helper functions ========
        // Compute skewness of a numeric array (Pearson's moment coefficient).
        function computeSkewness(values) {
            const nums = values.map(v => parseFloat(v)).filter(v => !isNaN(v));
            const n = nums.length;
            if (n < 3) return 0;
            const mean = nums.reduce((a, b) => a + b, 0) / n;
            const std = Math.sqrt(nums.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / (n - 1 || 1));
            if (std === 0) return 0;
            const m3 = nums.reduce((a, b) => a + Math.pow(b - mean, 3), 0) / n;
            const skew = m3 / Math.pow(std, 3);
            return skew;
        }

        // Interpret skewness and provide a textual description of the distribution shape.
        function interpretSkewness(skew) {
            if (isNaN(skew)) return '';
            if (skew > 0.5) return 'right‑skewed';
            if (skew < -0.5) return 'left‑skewed';
            return 'fairly symmetric';
        }

        // Summarise a numeric distribution: mean, median, skewness and overall shape.
        // Returns an HTML string with bolded variable names for improved readability.
        function summariseDistribution(name, values) {
            const nums = values.map(v => parseFloat(v)).filter(v => !isNaN(v));
            if (nums.length === 0) return '';
            const { mean, median, std } = computeStats(nums);
            const skew = computeSkewness(nums);
            const shape = interpretSkewness(skew);
            const meanStr = mean.toFixed(2);
            const medStr = median.toFixed(2);
            const skewStr = skew.toFixed(2);
            return `The variable <strong>${name}</strong> has a mean of <strong>${meanStr}</strong>, median of <strong>${medStr}</strong>, and a standard deviation of <strong>${std.toFixed(2)}</strong>. Its distribution appears <strong>${shape}</strong> (skewness = ${skewStr}).`;
        }

        // Summarise a categorical distribution: highlight the most frequent categories.
        function summariseCategorical(name, counts) {
            const entries = Object.entries(counts).sort((a, b) => b[1] - a[1]);
            const total = entries.reduce((acc, [_, c]) => acc + c, 0);
            if (entries.length === 0 || total === 0) return '';
            // List up to 3 top categories with percentages
            const tops = entries.slice(0, 3).map(([val, c]) => `${val} (${((c / total) * 100).toFixed(1)}%)`);
            return `The variable <strong>${name}</strong> is categorical. The most common categories are <strong>${tops.join(', ')}</strong>.`;
        }

        // Summarise correlation between two numeric variables given r and p.
        function summariseCorrelation(var1, var2, r, p) {
            const absR = Math.abs(r);
            let strength;
            if (absR >= 0.7) strength = 'a very strong';
            else if (absR >= 0.5) strength = 'a strong';
            else if (absR >= 0.3) strength = 'a moderate';
            else if (absR >= 0.1) strength = 'a weak';
            else strength = 'no meaningful';
            const direction = r > 0 ? 'positive' : (r < 0 ? 'negative' : 'neutral');
            const pStr = p < 0.0001 ? '&lt; 0.0001' : p.toFixed(4);
            const sig = p < 0.05 ? 'statistically significant' : 'not statistically significant';
            return `There is <strong>${strength}</strong> <strong>${direction}</strong> correlation between <strong>${var1}</strong> and <strong>${var2}</strong> (r = ${r.toFixed(2)}, p ≈ ${pStr}). This relationship is <strong>${sig}</strong>.`;
        }

        // Summarise group differences: highlight highest and lowest group means and interpret effect size.
        function summariseGroupDifference(numVar, catVar, categories, means, effect) {
            // Find highest and lowest means
            let maxIdx = 0;
            let minIdx = 0;
            for (let i = 1; i < means.length; i++) {
                if (means[i] > means[maxIdx]) maxIdx = i;
                if (means[i] < means[minIdx]) minIdx = i;
            }
            const highCat = categories[maxIdx];
            const lowCat = categories[minIdx];
            const highMean = means[maxIdx].toFixed(2);
            const lowMean = means[minIdx].toFixed(2);
            let magnitude;
            const absE = Math.abs(effect);
            if (absE >= 0.8) magnitude = 'a large';
            else if (absE >= 0.5) magnitude = 'a medium';
            else if (absE >= 0.2) magnitude = 'a small';
            else magnitude = 'a very small';
            return `For <strong>${numVar}</strong> by <strong>${catVar}</strong>, the highest mean is in group <strong>${highCat}</strong> (${highMean}), while the lowest mean is in group <strong>${lowCat}</strong> (${lowMean}). The effect size (Cohen’s d) is ${effect.toFixed(2)}, indicating <strong>${magnitude}</strong> difference between categories.`;
        }

        // Main logic
        const csvInput = document.getElementById('csvFile');
        const hypothesisInput = document.getElementById('hypothesis');
        const scopeInput = document.getElementById('scope');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const targetContainer = document.getElementById('target-container');
        const targetSelect = document.getElementById('targetSelect');
        const goalsGroup = document.getElementById('analysis-goals-group');
        const goalDescribe = document.getElementById('goalDescribe');
        const goalRelationship = document.getElementById('goalRelationship');
        const goalTests = document.getElementById('goalTests');
        const goalModel = document.getElementById('goalModel');
        const resultsSection = document.getElementById('results-section');
        const dataPreviewDiv = document.getElementById('data-preview');
        const overviewDiv = document.getElementById('overview');
        const numericSummaryDiv = document.getElementById('numeric-summary');
        const plotsDiv = document.getElementById('plots');

        // Report section reference (used when toggling display)
        const reportSection = document.getElementById('report-section');
        let parsedData = null;
        let numericCols = [];
        let categoricalCols = [];

        // Global variable to store correlation pairs across functions for suggestions
        let globalCorrPairs = [];

        // Arrays to store standard errors, confidence intervals and p-values for linear regression coefficients
        let linearSE = [];
        let linearCILow = [];
        let linearCIHigh = [];
        let linearPVals = [];

        // Store last used hypothesis and scope for reanalysis after cleaning/outlier removal
        let lastHypothesis = '';
        let lastScope = '';

        // History log: stores actions performed on the current dataset
        // Each entry contains a timestamp, an action label and a descriptive message.
        let historyLog = [];

        // Add a new entry to the history log and update the display
        function addHistory(action, details) {
            const timestamp = new Date().toISOString();
            historyLog.push({ timestamp, action, details });
            updateHistoryDisplay();
        }

        // Render the history table
        function updateHistoryDisplay() {
            const historySection = document.getElementById('history-section');
            const table = document.getElementById('historyTable');
            if (!table) return;
            // Show section if there are entries
            if (historyLog.length > 0) {
                historySection.style.display = 'block';
            }
            // Clear table
            table.innerHTML = '';
            // Create header
            const headerRow = document.createElement('tr');
            ['Time', 'Action', 'Details'].forEach(txt => {
                const th = document.createElement('th');
                th.textContent = txt;
                th.style.border = '1px solid #ddd';
                th.style.padding = '6px';
                th.style.backgroundColor = '#f2f2f2';
                headerRow.appendChild(th);
            });
            table.appendChild(headerRow);
            // Add entries
            historyLog.forEach(entry => {
                const tr = document.createElement('tr');
                [new Date(entry.timestamp).toLocaleString(), entry.action, entry.details].forEach(val => {
                    const td = document.createElement('td');
                    td.textContent = val;
                    td.style.border = '1px solid #ddd';
                    td.style.padding = '6px';
                    tr.appendChild(td);
                });
                table.appendChild(tr);
            });
        }

        // Download the history log as a CSV file
        function downloadHistory() {
            let csv = 'Timestamp,Action,Details\n';
            historyLog.forEach(e => {
                // Escape commas in action and details
                const act = (e.action || '').toString().replace(/,/g, ';');
                const det = (e.details || '').toString().replace(/,/g, ';');
                csv += `${e.timestamp},${act},${det}\n`;
            });
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'analysis_history.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Data management for cleaning and analysis
        let originalRows = [];
        let currentRows = [];

        // References to cleaning and modeling UI elements
        const cleaningSection = document.getElementById('cleaning-section');
        const missingValuesDiv = document.getElementById('missing-values');
        const missingStrategySelect = document.getElementById('missingStrategy');
        const applyCleaningBtn = document.getElementById('applyCleaningBtn');
        const zThresholdInput = document.getElementById('zThreshold');
        const removeOutliersBtn = document.getElementById('removeOutliersBtn');
        const modelingSection = document.getElementById('modeling-section');
        const modelSelect = document.getElementById('modelSelect');
        const modelOptions = document.getElementById('modelOptions');
        const runModelBtn = document.getElementById('runModelBtn');
        const modelResultsDiv = document.getElementById('modelResults');
        // Feature scaling selection
        const scalingSelect = document.getElementById('scalingSelect');

        csvInput.addEventListener('change', () => {
            analyzeBtn.disabled = !csvInput.files.length;
            // Show the analysis goals selector when a file is chosen
            if (csvInput.files.length > 0 && goalsGroup) {
                goalsGroup.style.display = 'block';
            }
        });

        analyzeBtn.addEventListener('click', () => {
            const file = csvInput.files[0];
            if (!file) return;
            const hypothesis = hypothesisInput.value.trim();
            const scope = scopeInput.value.trim();
            // Store selected analysis goals before reading the file
            const selectedGoals = {
                describe: goalDescribe ? goalDescribe.checked : true,
                relationship: goalRelationship ? goalRelationship.checked : true,
                tests: goalTests ? goalTests.checked : true,
                model: goalModel ? goalModel.checked : true
            };
            // Expose selected goals globally for use in displayResults
            window._selectedGoals = selectedGoals;
            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                parsedData = parseData(file.name, text);
                if (!parsedData) return;
                // Reset history for new dataset
                historyLog = [];
                updateHistoryDisplay();
                const { headers, rows } = parsedData;
                // Deep copy rows for original and current datasets
                originalRows = rows.map(r => Object.assign({}, r));
                currentRows = rows.map(r => Object.assign({}, r));
                // Determine numeric vs categorical columns based on currentRows
                numericCols = [];
                categoricalCols = [];
                for (const h of headers) {
                    const colValues = currentRows.map(r => r[h]);
                    if (isNumericColumn(colValues)) {
                        numericCols.push(h);
                    } else {
                        categoricalCols.push(h);
                    }
                }
                // Populate target select while preserving previous selection
                if (numericCols.length > 0) {
                    const previous = targetSelect.value;
                    targetSelect.innerHTML = '<option value="">(none)</option>';
                    numericCols.forEach(col => {
                        const opt = document.createElement('option');
                        opt.value = col;
                        opt.textContent = col;
                        targetSelect.appendChild(opt);
                    });
                    // Restore previous selection if still available
                    if (previous) {
                        targetSelect.value = previous;
                    }
                    targetContainer.style.display = 'block';
                } else {
                    targetContainer.style.display = 'none';
                }
                // Show preview table of first 5 rows
                dataPreviewDiv.innerHTML = '';
                const table = document.createElement('table');
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                headers.forEach(h => {
                    const th = document.createElement('th');
                    th.textContent = h;
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);
                table.appendChild(thead);
                const tbody = document.createElement('tbody');
                currentRows.slice(0, 5).forEach(row => {
                    const tr = document.createElement('tr');
                    headers.forEach(h => {
                        const td = document.createElement('td');
                        td.textContent = row[h];
                        tr.appendChild(td);
                    });
                    tbody.appendChild(tr);
                });
                table.appendChild(tbody);
                const caption = document.createElement('p');
                caption.textContent = `Preview of first 5 rows (Dataset has ${currentRows.length} rows and ${headers.length} columns)`;
                dataPreviewDiv.appendChild(caption);
                dataPreviewDiv.appendChild(table);
                // Perform analysis and display results on currentRows
                displayResults(hypothesis, scope);
                // Also update hypothesis and scope suggestions now that data has been analyzed
                if (typeof updateSuggestionsUI === 'function') {
                    updateSuggestionsUI();
                }
                // Log dataset load action
                addHistory('Load dataset', `Loaded ${file.name} with ${currentRows.length} rows and ${headers.length} columns`);
                // Show cleaning section always
                cleaningSection.style.display = 'block';
                // Show modeling section based on selected goals
                const goalsForModel = window._selectedGoals || { model: true };
                modelingSection.style.display = (goalsForModel.model ? 'block' : 'none');
                showMissingValues();
            };
            reader.readAsText(file);
        });

        function displayResults(hypothesis, scope) {
            // store hypothesis and scope for later reuse
            lastHypothesis = hypothesis;
            lastScope = scope;
            resultsSection.style.display = 'block';
            // Generate commentary and prepare report components
            const lines = [];
            lines.push(`Hypothesis: **${hypothesis || 'N/A'}**`);
            lines.push(`Scope: **${scope || 'N/A'}**`);
            lines.push('');
            lines.push(`The dataset contains **${currentRows.length}** rows and **${parsedData.headers.length}** columns.`);
            if (numericCols.length) {
                lines.push(`Numeric columns (${numericCols.length}): ${numericCols.join(', ')}.`);
            }
            if (categoricalCols.length) {
                lines.push(`Categorical columns (${categoricalCols.length}): ${categoricalCols.join(', ')}.`);
            }
            // Determine selected goals at the start of the result rendering. This object
            // controls which analyses to perform (describe, relationship, tests, model).
            const goals = window._selectedGoals || { describe: true, relationship: true, tests: true, model: true };

            // Stats for numeric columns
            numericSummaryDiv.innerHTML = '';
            const numericStats = {};
            if (goals.describe && numericCols.length) {
                const statsTable = document.createElement('table');
                const headRow = document.createElement('tr');
                ['Column','Mean','Median','Min','Max','Std Dev'].forEach(h => {
                    const th = document.createElement('th');
                    th.textContent = h;
                    headRow.appendChild(th);
                });
                const headT = document.createElement('thead');
                headT.appendChild(headRow);
                statsTable.appendChild(headT);
                const bodyT = document.createElement('tbody');
            numericCols.forEach(col => {
                    const values = currentRows.map(r => r[col]);
                    const { mean, median, min, max, std } = computeStats(values);
                    numericStats[col] = { mean, median, min, max, std };
                    const tr = document.createElement('tr');
                    [col, mean.toFixed(2), median.toFixed(2), min.toFixed(2), max.toFixed(2), std.toFixed(2)].forEach(val => {
                        const td = document.createElement('td');
                        td.textContent = val;
                        tr.appendChild(td);
                    });
                    bodyT.appendChild(tr);
                });
                statsTable.appendChild(bodyT);
                const caption = document.createElement('p');
                caption.textContent = 'Summary statistics for numeric columns';
                numericSummaryDiv.appendChild(caption);
                numericSummaryDiv.appendChild(statsTable);
            }
            // Category counts for categorical columns
            const categoryCounts = {};
            categoricalCols.forEach(col => {
                const values = currentRows.map(r => r[col]);
                const counts = {};
                values.forEach(v => {
                    counts[v] = (counts[v] || 0) + 1;
                });
                categoryCounts[col] = counts;
                const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]).slice(0, 5);
                lines.push(`Top values in **${col}**: ${sorted.map(([v,c]) => `${v} (${c})`).join(', ')}.`);
            });
            // Correlation analysis and plotting
            plotsDiv.innerHTML = '';
            let corrMatrix = null;
            let corrPairs = [];
            if (numericCols.length > 0) {
                // Determine selected goals for relationship and descriptive analyses
                // (goals variable already defined at start of displayResults)
                // Relationship goal: compute correlations and scatter plots
                if (goals.relationship) {
                    // Determine correlation method (Pearson or Spearman)
                    const corrMethodElem = document.getElementById('corrMethod');
                    const corrMethod = corrMethodElem ? corrMethodElem.value : 'pearson';
                    const corrFunc = (corrMethod === 'spearman') ? computeSpearmanCorrelation : computeCorrelation;
                    // Compute correlation matrix
                    corrMatrix = [];
                    for (let i = 0; i < numericCols.length; i++) {
                        corrMatrix[i] = [];
                        for (let j = 0; j < numericCols.length; j++) {
                            if (i === j) {
                                corrMatrix[i][j] = 1;
                            } else if (j < i) {
                                corrMatrix[i][j] = corrMatrix[j][i];
                            } else {
                                const xVals = currentRows.map(r => r[numericCols[i]]);
                                const yVals = currentRows.map(r => r[numericCols[j]]);
                                const corr = corrFunc(xVals, yVals);
                                corrMatrix[i][j] = corr;
                            }
                        }
                    }
                    // Determine top correlations excluding diagonal
                    corrPairs = [];
                    for (let i = 0; i < numericCols.length; i++) {
                        for (let j = i + 1; j < numericCols.length; j++) {
                            corrPairs.push({ cols: [numericCols[i], numericCols[j]], val: Math.abs(corrMatrix[i][j]) });
                        }
                    }
                    corrPairs.sort((a, b) => b.val - a.val);
                    // Make correlation pairs available globally for suggestions
                    globalCorrPairs = corrPairs.slice();
                    if (corrPairs.length > 0) {
                        lines.push('\nStrongest correlations between numeric variables:');
                        corrPairs.slice(0, Math.min(5, corrPairs.length)).forEach(p => {
                            const corrVal = corrMatrix[numericCols.indexOf(p.cols[0])][numericCols.indexOf(p.cols[1])];
                            lines.push(`- ${p.cols[0]} vs ${p.cols[1]}: correlation = ${corrVal.toFixed(2)}`);
                        });
                    }
                    // Plot heatmap
                    const heatCanvas = document.createElement('canvas');
                    heatCanvas.width = 500;
                    heatCanvas.height = 500;
                    const heatTitle = document.createElement('h3');
                    heatTitle.textContent = 'Correlation heatmap';
                    plotsDiv.appendChild(heatTitle);
                    plotsDiv.appendChild(heatCanvas);
                    drawHeatmap(heatCanvas, corrMatrix, numericCols);
                    // Summarise top correlation pairs (up to 3) and append narrative
                    const heatSummary = document.createElement('p');
                    heatSummary.className = 'commentary';
                    let heatSummaryText = '';
                    const maxPairs = Math.min(3, corrPairs.length);
                    for (let i = 0; i < maxPairs; i++) {
                        const pair = corrPairs[i];
                        const xCol = pair.cols[0];
                        const yCol = pair.cols[1];
                        const rVal = corrMatrix[numericCols.indexOf(xCol)][numericCols.indexOf(yCol)];
                        // Compute p-value approximation using t-distribution approximation
                        const valsX = currentRows.map(r => r[xCol]);
                        const valsY = currentRows.map(r => r[yCol]);
                        let nPairs = 0;
                        for (let j = 0; j < valsX.length; j++) {
                            const xv = parseFloat(valsX[j]);
                            const yv = parseFloat(valsY[j]);
                            if (!isNaN(xv) && !isNaN(yv)) nPairs++;
                        }
                        let pVal = 1.0;
                        if (nPairs > 2 && Math.abs(rVal) < 1) {
                            const tVal = rVal * Math.sqrt(nPairs - 2) / Math.sqrt(1 - rVal * rVal);
                            const zVal = Math.abs(tVal);
                            pVal = 2 * (1 - 0.5 * (1 + erf(zVal / Math.sqrt(2))));
                        }
                        const summary = summariseCorrelation(xCol, yCol, rVal, pVal);
                        heatSummaryText += summary + '<br/>';
                    }
                    if (heatSummaryText) {
                        heatSummary.innerHTML = heatSummaryText;
                        plotsDiv.appendChild(heatSummary);
                    }
                    // Scatter plots for top correlated pairs
                    const topPairs = corrPairs.slice(0, Math.min(3, corrPairs.length));
                    topPairs.forEach((pair, idx) => {
                        const xCol = pair.cols[0];
                        const yCol = pair.cols[1];
                        const scatterCanvas = document.createElement('canvas');
                        scatterCanvas.width = 400;
                        scatterCanvas.height = 300;
                        const scatterTitle = document.createElement('h3');
                        scatterTitle.textContent = `${xCol} vs ${yCol}`;
                        plotsDiv.appendChild(scatterTitle);
                        plotsDiv.appendChild(scatterCanvas);
                        const xValues = currentRows.map(r => r[xCol]);
                        const yValues = currentRows.map(r => r[yCol]);
                        // Assign a colour from the palette based on index
                        const scatterColor = colorPalette[idx % colorPalette.length];
                        drawScatter(scatterCanvas, xValues, yValues, xCol, yCol, scatterColor);
                        // Compute correlation and p-value for summary
                        let rVal = corrMatrix[numericCols.indexOf(xCol)][numericCols.indexOf(yCol)];
                        // Determine sample size and compute p-value
                        let nPairs = 0;
                        for (let k = 0; k < xValues.length; k++) {
                            const xv = parseFloat(xValues[k]);
                            const yv = parseFloat(yValues[k]);
                            if (!isNaN(xv) && !isNaN(yv)) nPairs++;
                        }
                        let pVal = 1.0;
                        if (nPairs > 2 && Math.abs(rVal) < 1) {
                            const tVal = rVal * Math.sqrt(nPairs - 2) / Math.sqrt(1 - rVal * rVal);
                            const zVal = Math.abs(tVal);
                            pVal = 2 * (1 - 0.5 * (1 + erf(zVal / Math.sqrt(2))));
                        }
                        const corrSummary = summariseCorrelation(xCol, yCol, rVal, pVal);
                        const corrSummaryP = document.createElement('p');
                        corrSummaryP.className = 'commentary';
                        corrSummaryP.innerHTML = corrSummary;
                        plotsDiv.appendChild(corrSummaryP);
                    });
                }
                // Descriptive goal: histograms and box plots for numeric columns
                if (goals.describe) {
                    numericCols.forEach((col, idx) => {
                        const histCanvas = document.createElement('canvas');
                        histCanvas.width = 400;
                        histCanvas.height = 300;
                        const histTitle = document.createElement('h3');
                        histTitle.textContent = `Distribution of ${col}`;
                        plotsDiv.appendChild(histTitle);
                        plotsDiv.appendChild(histCanvas);
                        const values = currentRows.map(r => r[col]);
                        // Assign colour from palette for each numeric column
                        const histColor = colorPalette[idx % colorPalette.length];
                        drawHistogram(histCanvas, values, col, histColor);
                        // Append distribution summary below each histogram
                        const histSummary = summariseDistribution(col, values);
                        if (histSummary) {
                            const summaryP = document.createElement('p');
                            summaryP.className = 'commentary';
                            summaryP.innerHTML = histSummary;
                            plotsDiv.appendChild(summaryP);
                        }
                    });
                    // Additionally draw box plots to visualise quartiles and outliers. Limit to first 5 numeric variables to avoid clutter.
                    const numForBox = Math.min(5, numericCols.length);
                    for (let i = 0; i < numForBox; i++) {
                        const col = numericCols[i];
                        const boxCanvas = document.createElement('canvas');
                        boxCanvas.width = 400;
                        boxCanvas.height = 200;
                        const boxTitle = document.createElement('h3');
                        boxTitle.textContent = `Box plot of ${col}`;
                        plotsDiv.appendChild(boxTitle);
                        plotsDiv.appendChild(boxCanvas);
                        const values = currentRows.map(r => r[col]);
                        const boxColor = colorPalette[(numericCols.length + i) % colorPalette.length];
                        drawBoxPlot(boxCanvas, values, col, boxColor);
                    }
                }
            }
            // Bar charts for categorical variables
            if (categoricalCols.length > 0) {
                categoricalCols.forEach((col, idx) => {
                    const counts = categoryCounts[col];
                    const labels = Object.keys(counts);
                    const valuesArr = labels.map(l => counts[l]);
                    const barCanvas = document.createElement('canvas');
                    barCanvas.width = 400;
                    barCanvas.height = 300;
                    const barTitle = document.createElement('h3');
                    barTitle.textContent = `Distribution of ${col}`;
                    plotsDiv.appendChild(barTitle);
                    plotsDiv.appendChild(barCanvas);
                    // Use a colour from the palette for categorical distributions
                    const barColor = colorPalette[(numericCols.length + idx) % colorPalette.length];
                    drawBarChart(barCanvas, labels, valuesArr, barColor);
                    // Append categorical distribution summary
                    const catSummary = summariseCategorical(col, counts);
                    if (catSummary) {
                        const catP = document.createElement('p');
                        catP.className = 'commentary';
                        catP.innerHTML = catSummary;
                        plotsDiv.appendChild(catP);
                    }
                });
            }
            // Display group difference chart for the strongest numeric-categorical combination with effect size and confidence intervals
            if ((goals.relationship || goals.tests) && numericCols.length > 0 && categoricalCols.length > 0) {
                const groupDiffs = [];
                categoricalCols.forEach(cat => {
                    const categories = Object.keys(categoryCounts[cat]);
                    // Only consider a reasonable number of categories
                    if (categories.length < 2 || categories.length > 8) return;
                    numericCols.forEach(num => {
                        // Compute group means, stds, counts and confidence intervals
                        const groupMeans = [];
                        const groupStd = [];
                        const groupN = [];
                        const ciLow = [];
                        const ciHigh = [];
                        categories.forEach(catValue => {
                            const vals = currentRows.filter(r => r[cat] === catValue).map(r => r[num]).map(v => parseFloat(v)).filter(v => !isNaN(v));
                            const nVal = vals.length;
                            if (nVal === 0) {
                                groupMeans.push(NaN);
                                groupStd.push(NaN);
                                groupN.push(0);
                                ciLow.push(NaN);
                                ciHigh.push(NaN);
                                return;
                            }
                            const meanVal = vals.reduce((a, b) => a + b, 0) / nVal;
                            const variance = vals.reduce((a, b) => a + Math.pow(b - meanVal, 2), 0) / ((nVal - 1) || 1);
                            const stdVal = Math.sqrt(variance);
                            const ciMargin = 1.96 * (stdVal / Math.sqrt(nVal));
                            groupMeans.push(meanVal);
                            groupStd.push(stdVal);
                            groupN.push(nVal);
                            ciLow.push(meanVal - ciMargin);
                            ciHigh.push(meanVal + ciMargin);
                        });
                        if (groupMeans.some(m => isNaN(m))) return;
                        // Compute pooled standard deviation for effect size
                        const totalN = groupN.reduce((a, b) => a + b, 0);
                        const sumSq = groupStd.reduce((acc, sd, idx) => acc + (groupN[idx] - 1) * sd * sd, 0);
                        const pooledVar = (totalN - categories.length) > 0 ? sumSq / (totalN - categories.length) : 0;
                        const pooledStd = Math.sqrt(pooledVar);
                        const diffEffect = pooledStd > 0 ? (Math.max(...groupMeans) - Math.min(...groupMeans)) / pooledStd : 0;
                        groupDiffs.push({ cat, num, effect: Math.abs(diffEffect), categories, means: groupMeans, ciLow, ciHigh });
                    });
                });
                groupDiffs.sort((a, b) => b.effect - a.effect);
                if (groupDiffs.length > 0) {
                    const top = groupDiffs[0];
                    const diffCanvas = document.createElement('canvas');
                    diffCanvas.width = 400;
                    diffCanvas.height = 300;
                    const diffTitle = document.createElement('h3');
                    diffTitle.textContent = `Mean of ${top.num} by ${top.cat} (effect size ≈ ${top.effect.toFixed(2)})`;
                    plotsDiv.appendChild(diffTitle);
                    plotsDiv.appendChild(diffCanvas);
                    const diffColorIndex = numericCols.length + categoricalCols.length;
                    const diffColor = colorPalette[diffColorIndex % colorPalette.length];
                    drawGroupedMeanChart(diffCanvas, top.categories, top.means, top.ciLow, top.ciHigh, top.num, top.cat, diffColor);
                    lines.push(`Largest difference of means: ${top.num} by ${top.cat} (effect size ≈ ${top.effect.toFixed(2)})`);
                    // Append summary for group difference chart
                    const diffSummary = summariseGroupDifference(top.num, top.cat, top.categories, top.means, top.effect);
                    if (diffSummary) {
                        const diffP = document.createElement('p');
                        diffP.className = 'commentary';
                        diffP.innerHTML = diffSummary;
                        plotsDiv.appendChild(diffP);
                    }
                }
            }
            // Regression models
            const target = targetSelect.value;
            let linearCoeffs = null;
            let logisticCoeffs = null;
            let linearPredictors = [];
            let logisticPredictors = [];
            // Linear regression when numeric target with numeric predictors
            if (target && numericCols.includes(target)) {
                if (numericCols.length > 1) {
                    linearPredictors = numericCols.filter(c => c !== target);
                    const X = currentRows.map(r => linearPredictors.map(p => parseFloat(r[p]) || 0));
                    const y = currentRows.map(r => parseFloat(r[target]) || 0);
                    // Add intercept
                    for (let i = 0; i < X.length; i++) {
                        X[i] = [1, ...X[i]];
                    }
                    // Helper functions
                    function transpose(A) {
                        return A[0].map((_, i) => A.map(row => row[i]));
                    }
                    function multiply(A, B) {
                        const result = Array.from({ length: A.length }, () => Array(B[0].length).fill(0));
                        for (let i = 0; i < A.length; i++) {
                            for (let j = 0; j < B[0].length; j++) {
                                for (let k = 0; k < B.length; k++) {
                                    result[i][j] += A[i][k] * B[k][j];
                                }
                            }
                        }
                        return result;
                    }
                    function inverse(matrix) {
                        const n = matrix.length;
                        const I = matrix.map((row, i) => row.map((_, j) => (i === j ? 1 : 0)));
                        const augmented = matrix.map((row, i) => row.concat(I[i]));
                        for (let i = 0; i < n; i++) {
                            let pivot = augmented[i][i];
                            if (pivot === 0) {
                                for (let k = i + 1; k < n; k++) {
                                    if (augmented[k][i] !== 0) {
                                        [augmented[i], augmented[k]] = [augmented[k], augmented[i]];
                                        pivot = augmented[i][i];
                                        break;
                                    }
                                }
                            }
                            if (pivot === 0) return null;
                            for (let j = 0; j < 2 * n; j++) augmented[i][j] /= pivot;
                            for (let k = 0; k < n; k++) {
                                if (k === i) continue;
                                const factor = augmented[k][i];
                                for (let j = 0; j < 2 * n; j++) {
                                    augmented[k][j] -= factor * augmented[i][j];
                                }
                            }
                        }
                        return augmented.map(row => row.slice(n));
                    }
                    const XT = transpose(X);
                    const XTX = multiply(XT, X);
                    const inv = inverse(XTX);
                    if (inv) {
                        const XTy = multiply(XT, y.map(v => [v]));
                        const beta = multiply(inv, XTy);
                        linearCoeffs = beta.map(b => b[0]);
                        // Compute residuals to estimate variance and standard errors
                        const nObs = X.length;
                        const pDim = beta.length;
                        // Predicted values yHat
                        const yHat = [];
                        for (let i = 0; i < nObs; i++) {
                            let sum = 0;
                            for (let j = 0; j < pDim; j++) {
                                sum += X[i][j] * beta[j][0];
                            }
                            yHat[i] = sum;
                        }
                        const residuals = [];
                        for (let i = 0; i < y.length; i++) {
                            residuals.push(y[i] - yHat[i]);
                        }
                        const rss = residuals.reduce((acc, v) => acc + v * v, 0);
                        const sigma2 = (nObs - pDim) > 0 ? rss / (nObs - pDim) : rss;
                        // Compute covariance matrix of coefficients: sigma2 * inv
                        const covMatrix = [];
                        for (let i = 0; i < inv.length; i++) {
                            covMatrix[i] = [];
                            for (let j = 0; j < inv[i].length; j++) {
                                covMatrix[i][j] = inv[i][j] * sigma2;
                            }
                        }
                        // Standard errors, confidence intervals and p-values
                        const seCoeffs = [];
                        const ciLowCoeffs = [];
                        const ciHighCoeffs = [];
                        const pVals = [];
                        for (let i = 0; i < linearCoeffs.length; i++) {
                            const seVal = Math.sqrt(Math.abs(covMatrix[i][i]));
                            seCoeffs.push(seVal);
                            const tVal = seVal > 0 ? (linearCoeffs[i] / seVal) : 0;
                            const pVal = 2 * (1 - 0.5 * (1 + erf(Math.abs(tVal) / Math.sqrt(2))));
                            pVals.push(pVal);
                            const ciLow = linearCoeffs[i] - 1.96 * seVal;
                            const ciHigh = linearCoeffs[i] + 1.96 * seVal;
                            ciLowCoeffs.push(ciLow);
                            ciHighCoeffs.push(ciHigh);
                        }
                        lines.push('\nRegression model to predict **' + target + '** using numeric features:');
                        // Intercept with SE, CI, p
                        lines.push(`Intercept: ${linearCoeffs[0].toFixed(4)} (SE=${seCoeffs[0].toFixed(4)}, CI=[${ciLowCoeffs[0].toFixed(4)}, ${ciHighCoeffs[0].toFixed(4)}], p≈${pVals[0].toFixed(4)})`);
                        linearPredictors.forEach((p, idx) => {
                            const i = idx + 1;
                            lines.push(`Coefficient for ${p}: ${linearCoeffs[i].toFixed(4)} (SE=${seCoeffs[i].toFixed(4)}, CI=[${ciLowCoeffs[i].toFixed(4)}, ${ciHighCoeffs[i].toFixed(4)}], p≈${pVals[i].toFixed(4)})`);
                        });
                        // Store these statistics globally for report generation
                        linearSE = seCoeffs;
                        linearCILow = ciLowCoeffs;
                        linearCIHigh = ciHighCoeffs;
                        linearPVals = pVals;
                    } else {
                        lines.push('\nCould not compute regression coefficients (matrix singular).');
                    }
                }
            }
            // Logistic regression for binary target (categorical with two unique values)
            if (target) {
                // Determine if target is binary
                const targetValues = currentRows.map(r => r[target]);
                const uniqueVals = Array.from(new Set(targetValues.map(v => String(v))));
                if (uniqueVals.length === 2) {
                    // Map uniqueVals to 0 and 1
                    const mapping = {};
                    mapping[uniqueVals[0]] = 0;
                    mapping[uniqueVals[1]] = 1;
                    // Use numeric predictors only
                    const predictors = numericCols.filter(c => c !== target);
                    logisticPredictors = predictors;
                    if (predictors.length > 0) {
                        const X = currentRows.map(r => predictors.map(p => parseFloat(r[p]) || 0));
                        const yBin = currentRows.map(r => mapping[String(r[target])]);
                        // Add intercept
                        for (let i = 0; i < X.length; i++) {
                            X[i] = [1, ...X[i]];
                        }
                        // Initialize coefficients
                        const pDim = X[0].length;
                        let beta = new Array(pDim).fill(0);
                        const iterations = 200;
                        const lr = 0.01;
                        for (let iter = 0; iter < iterations; iter++) {
                            const gradients = new Array(pDim).fill(0);
                            for (let i = 0; i < X.length; i++) {
                                let z = 0;
                                for (let j = 0; j < pDim; j++) z += X[i][j] * beta[j];
                                const pred = 1 / (1 + Math.exp(-z));
                                const err = yBin[i] - pred;
                                for (let j = 0; j < pDim; j++) gradients[j] += err * X[i][j];
                            }
                            for (let j = 0; j < pDim; j++) beta[j] += lr * gradients[j];
                        }
                        logisticCoeffs = beta;
                        lines.push('\nLogistic regression to predict binary outcome **' + target + '** using numeric predictors:');
                        lines.push(`Intercept: ${beta[0].toFixed(4)}`);
                        predictors.forEach((p, idx) => {
                            lines.push(`Coefficient for ${p}: ${beta[idx + 1].toFixed(4)}`);
                        });
                    }
                }
            }
            // Generate suggestions based on results
            function generateSuggestions() {
                const sugg = [];
                // Suggestions from correlation
                if (corrPairs && corrPairs.length > 0) {
                    const firstPair = corrPairs[0];
                    sugg.push(`Consider running a regression to test whether **${firstPair.cols[0]}** predicts **${firstPair.cols[1]}** or vice versa.`);
                }
                // Numeric vs categorical differences
                if (numericCols.length > 0 && categoricalCols.length > 0) {
                    const ncol = numericCols[0];
                    const ccol = categoricalCols[0];
                    const groupMeans = {};
                    for (const row of currentRows) {
                        const cat = row[ccol];
                        const num = parseFloat(row[ncol]);
                        if (!isNaN(num)) {
                            if (!groupMeans[cat]) groupMeans[cat] = [];
                            groupMeans[cat].push(num);
                        }
                    }
                    const means = Object.entries(groupMeans).map(([cat, arr]) => {
                        const m = arr.reduce((a,b) => a+b,0)/arr.length;
                        return { cat, mean: m };
                    });
                    if (means.length > 1) {
                        means.sort((a,b) => b.mean - a.mean);
                        const diff = means[0].mean - means[means.length-1].mean;
                        const pooledStd = computeStats(currentRows.map(r => r[ncol])).std;
                        if (pooledStd > 0 && diff / pooledStd > 0.5) {
                            sugg.push(`Investigate differences in **${ncol}** across categories of **${ccol}**; there appears to be a notable gap between groups.`);
                        }
                    }
                }
                // Suggestions from logistic regression
                if (logisticCoeffs && logisticPredictors.length > 0) {
                    // Find predictor with largest absolute coefficient
                    let maxIdx = 0;
                    let maxVal = Math.abs(logisticCoeffs[1]);
                    for (let i = 1; i < logisticPredictors.length; i++) {
                        const val = Math.abs(logisticCoeffs[i+1]);
                        if (val > maxVal) { maxVal = val; maxIdx = i; }
                    }
                    const predName = logisticPredictors[maxIdx];
                    sugg.push(`In the logistic model, **${predName}** seems to be the strongest predictor of **${target}**. Consider exploring why this relationship exists.`);
                }
                return sugg;
            }
            const suggestions = generateSuggestions();
            if (suggestions.length > 0) {
                lines.push('\nSuggestions for further analysis:');
                suggestions.forEach(s => lines.push('- ' + s));
            }
            // Display commentary
            overviewDiv.innerHTML = lines.join('\n');
            // Generate report and display report section
            function generateReport() {
                let report = '';
                report += '# Analysis Report\n\n';
                report += `## Hypothesis\n${hypothesis || 'N/A'}\n\n`;
                report += `## Scope\n${scope || 'N/A'}\n\n`;
                report += `## Data Overview\nThe dataset contains ${currentRows.length} rows and ${parsedData.headers.length} columns.\n`;
                report += `\nNumeric columns (${numericCols.length}): ${numericCols.join(', ')}.\n`;
                report += `Categorical columns (${categoricalCols.length}): ${categoricalCols.join(', ')}.\n`;
                // Summary stats section
                if (numericCols.length > 0) {
                    report += '\n### Summary Statistics\n';
                    numericCols.forEach(col => {
                        const s = numericStats[col];
                        report += `- **${col}**: mean=${s.mean.toFixed(2)}, median=${s.median.toFixed(2)}, min=${s.min.toFixed(2)}, max=${s.max.toFixed(2)}, std=${s.std.toFixed(2)}\n`;
                    });
                }
                // Top categories
                if (categoricalCols.length > 0) {
                    report += '\n### Categorical Distributions\n';
                    categoricalCols.forEach(col => {
                        const entries = Object.entries(categoryCounts[col]).sort((a,b) => b[1] - a[1]).slice(0,5);
                        report += `- **${col}**: ` + entries.map(([v,c]) => `${v} (${c})`).join(', ') + '\n';
                    });
                }
                // Correlations
                if (corrPairs && corrPairs.length > 0) {
                    report += '\n### Correlations\n';
                    corrPairs.slice(0, Math.min(5, corrPairs.length)).forEach(p => {
                        const corrVal = corrMatrix[numericCols.indexOf(p.cols[0])][numericCols.indexOf(p.cols[1])];
                        report += `- ${p.cols[0]} vs ${p.cols[1]}: r=${corrVal.toFixed(2)}\n`;
                    });
                }
                // Regression models
                if (linearCoeffs) {
                    report += '\n### Linear Regression\n';
                    report += `Target variable: ${target}\n`;
                    // Include standard errors, confidence intervals and p-values if available
                    if (linearSE && linearSE.length > 0) {
                        report += `Intercept: ${linearCoeffs[0].toFixed(4)} (SE=${linearSE[0].toFixed(4)}, CI=[${linearCILow[0].toFixed(4)}, ${linearCIHigh[0].toFixed(4)}], p≈${linearPVals[0].toFixed(4)})\n`;
                        linearPredictors.forEach((p, idx) => {
                            const i = idx + 1;
                            report += `Coefficient for ${p}: ${linearCoeffs[i].toFixed(4)} (SE=${linearSE[i].toFixed(4)}, CI=[${linearCILow[i].toFixed(4)}, ${linearCIHigh[i].toFixed(4)}], p≈${linearPVals[i].toFixed(4)})\n`;
                        });
                    } else {
                        report += `Intercept: ${linearCoeffs[0].toFixed(4)}\n`;
                        linearPredictors.forEach((p, idx) => {
                            report += `Coefficient for ${p}: ${linearCoeffs[idx + 1].toFixed(4)}\n`;
                        });
                    }
                }
                if (logisticCoeffs) {
                    report += '\n### Logistic Regression\n';
                    report += `Binary target variable: ${target}\n`;
                    report += `Intercept: ${logisticCoeffs[0].toFixed(4)}\n`;
                    logisticPredictors.forEach((p, idx) => {
                        report += `Coefficient for ${p}: ${logisticCoeffs[idx + 1].toFixed(4)}\n`;
                    });
                }
                // Suggestions
                if (suggestions.length > 0) {
                    report += '\n### Suggestions for Further Analysis\n';
                    suggestions.forEach(s => { report += `- ${s}\n`; });
                }
                report += '\n*This report was automatically generated. You can edit the text as needed before downloading.*\n';
                return report;
            }
            const reportText = generateReport();
            document.getElementById('reportArea').value = reportText;
            reportSection.style.display = 'block';
            // Update suggested hypotheses and scopes based on current analysis
            if (typeof updateSuggestionsUI === 'function') {
                updateSuggestionsUI();
            }
            // Display diagnostics section, duplicates summary, and test options based on selected goals
            const extras = document.getElementById('extras-section');
            const testsSection = document.getElementById('tests-section');
            if (extras) extras.style.display = 'block';
            if (typeof showDuplicates === 'function') showDuplicates();
            if (testsSection) {
                testsSection.style.display = goals.tests ? 'block' : 'none';
            }
            if (goals.tests && typeof updateTestOptions === 'function') updateTestOptions();
            const downloadBtn = document.getElementById('downloadCleanedBtn');
            if (downloadBtn) downloadBtn.style.display = 'inline-block';
        }

        // =============================================
        // Suggestion generation for hypothesis and scope
        // These helper functions analyse the currently loaded dataset and propose
        // potential hypotheses and scope descriptions to guide the user.
        function generateHypothesisSuggestionsList() {
            const suggestions = [];
            // Suggest exploring strong correlations between numeric variables. Propose up to two pairs.
            if (typeof globalCorrPairs !== 'undefined' && globalCorrPairs && globalCorrPairs.length > 0) {
                const maxPairs = Math.min(2, globalCorrPairs.length);
                for (let i = 0; i < maxPairs; i++) {
                    const pair = globalCorrPairs[i];
                    suggestions.push(`Explore the relationship between ${pair.cols[0]} and ${pair.cols[1]}. A correlation analysis or regression might reveal interesting patterns.`);
                }
            }
            // Suggest differences across groups: find the numeric/categorical pair with the largest standardized mean difference.
            if (numericCols.length > 0 && categoricalCols.length > 0) {
                let bestPair = null;
                let bestEffect = 0;
                // Iterate over all numeric and categorical combinations
                for (const ncol of numericCols) {
                    for (const ccol of categoricalCols) {
                        const groups = {};
                        for (const row of currentRows) {
                            const cat = row[ccol];
                            const val = parseFloat(row[ncol]);
                            if (!isNaN(val)) {
                                if (!groups[cat]) groups[cat] = [];
                                groups[cat].push(val);
                            }
                        }
                        const groupArrays = Object.values(groups);
                        const labels = Object.keys(groups);
                        if (groupArrays.length < 2) continue;
                        // Compute group means and pooled variance
                        let pooledSS = 0;
                        let totalCount = 0;
                        const means = groupArrays.map(arr => {
                            const m = arr.reduce((a,b) => a + b, 0) / arr.length;
                            // accumulate pooled SS
                            arr.forEach(v => {
                                pooledSS += Math.pow(v - m, 2);
                                totalCount++;
                            });
                            return m;
                        });
                        const pooledVar = (groupArrays.length > 1 && totalCount - groupArrays.length > 0) ? pooledSS / (totalCount - groupArrays.length) : 0;
                        const pooledSD = Math.sqrt(pooledVar);
                        // Determine max and min means
                        let maxIdx = 0;
                        let minIdx = 0;
                        for (let i = 1; i < means.length; i++) {
                            if (means[i] > means[maxIdx]) maxIdx = i;
                            if (means[i] < means[minIdx]) minIdx = i;
                        }
                        const diff = means[maxIdx] - means[minIdx];
                        const effect = (pooledSD > 0) ? (diff / pooledSD) : 0;
                        if (effect > bestEffect) {
                            bestEffect = effect;
                            bestPair = { num: ncol, cat: ccol, maxCat: labels[maxIdx], minCat: labels[minIdx] };
                        }
                    }
                }
                // If a substantial effect size is found, suggest investigating this difference.
                if (bestPair && bestEffect > 0.5) {
                    suggestions.push(`Investigate whether the average value of ${bestPair.num} differs across categories of ${bestPair.cat}. There is a notable difference between ${bestPair.maxCat} and ${bestPair.minCat} (effect size ≈ ${bestEffect.toFixed(2)}).`);
                }
            }
            // Suggest modelling opportunities: regression, classification or clustering
            // If a numeric target is selected or available, propose regression
            const targetVar = (targetSelect && targetSelect.value) ? targetSelect.value : '';
            if (targetVar) {
                // Determine if selected target is binary (classification) or numeric (regression)
                const targetVals = currentRows.map(r => String(r[targetVar]));
                const uniq = Array.from(new Set(targetVals));
                if (uniq.length === 2) {
                    suggestions.push(`Since ${targetVar} has two categories, try a classification model (e.g., logistic regression or K‑nearest neighbours) to predict it from other variables.`);
                } else {
                    suggestions.push(`Consider building a regression model to predict ${targetVar} using numeric predictors.`);
                }
            } else {
                // If no target selected, suggest exploring predictive modelling if there are multiple numeric variables
                if (numericCols.length >= 2) {
                    suggestions.push('With multiple numeric variables, you can explore regression or classification by choosing a target variable.');
                }
            }
            // Suggest clustering if there are at least three numeric predictors
            if (numericCols.length >= 3) {
                suggestions.push('Unsupervised clustering (e.g., k‑means) could reveal hidden groups in your data.');
            }
            return suggestions;
        }

        function generateScopeSuggestionsList() {
            const suggestions = [];
            // Suggest focusing on categories for comparative analysis
            if (categoricalCols.length > 0) {
                const cat = categoricalCols[0];
                suggestions.push(`Compare results across different categories of ${cat}, or focus on a specific group to see its impact on numeric variables.`);
            }
            // Suggest focusing on numeric variables for correlation and modelling
            if (numericCols.length > 1) {
                suggestions.push('Concentrate on exploring correlations among numeric variables and building predictive models.');
            }
            // General suggestion to refine scope
            suggestions.push('Restrict analysis to features most relevant to your research question or available resources.');
            return suggestions;
        }

        // Update the suggestions lists in the UI
        function updateSuggestionsUI() {
            const section = document.getElementById('suggestions-section');
            const hypoList = document.getElementById('hypothesisSuggestions');
            const scopeList = document.getElementById('scopeSuggestions');
            if (!section || !hypoList || !scopeList) return;
            const hyps = generateHypothesisSuggestionsList();
            const scopes = generateScopeSuggestionsList();
            // Populate hypothesis suggestions
            hypoList.innerHTML = '';
            hyps.forEach(text => {
                const li = document.createElement('li');
                li.textContent = text;
                hypoList.appendChild(li);
            });
            // Populate scope suggestions
            scopeList.innerHTML = '';
            scopes.forEach(text => {
                const li = document.createElement('li');
                li.textContent = text;
                scopeList.appendChild(li);
            });
            // Show section if there are suggestions
            if (hyps.length > 0 || scopes.length > 0) {
                section.style.display = 'block';
            } else {
                section.style.display = 'none';
            }
            // Also update placeholders on hypothesis and scope input fields to guide the user
            if (typeof hypothesisInput !== 'undefined' && hypothesisInput) {
                hypothesisInput.placeholder = hyps.length > 0 ? hyps[0] : hypothesisInput.placeholder;
            }
            if (typeof scopeInput !== 'undefined' && scopeInput) {
                scopeInput.placeholder = scopes.length > 0 ? scopes[0] : scopeInput.placeholder;
            }
        }

        // =============================================

        // =============================================
        // Data cleaning, modeling and additional utilities
        // =============================================

        // Matrix helper functions for linear regression
        function transposeMatrix(A) {
            return A[0].map((_, i) => A.map(row => row[i]));
        }
        function multiplyMatrices(A, B) {
            const result = Array.from({ length: A.length }, () => Array(B[0].length).fill(0));
            for (let i = 0; i < A.length; i++) {
                for (let j = 0; j < B[0].length; j++) {
                    for (let k = 0; k < B.length; k++) {
                        result[i][j] += A[i][k] * B[k][j];
                    }
                }
            }
            return result;
        }
        function invertMatrix(matrix) {
            const n = matrix.length;
            const I = matrix.map((row, i) => row.map((_, j) => (i === j ? 1 : 0)));
            const augmented = matrix.map((row, i) => row.concat(I[i]));
            for (let i = 0; i < n; i++) {
                let pivot = augmented[i][i];
                if (pivot === 0) {
                    for (let k = i + 1; k < n; k++) {
                        if (augmented[k][i] !== 0) {
                            [augmented[i], augmented[k]] = [augmented[k], augmented[i]];
                            pivot = augmented[i][i];
                            break;
                        }
                    }
                }
                if (pivot === 0) return null;
                for (let j = 0; j < 2 * n; j++) augmented[i][j] /= pivot;
                for (let k = 0; k < n; k++) {
                    if (k === i) continue;
                    const factor = augmented[k][i];
                    for (let j = 0; j < 2 * n; j++) {
                        augmented[k][j] -= factor * augmented[i][j];
                    }
                }
            }
            return augmented.map(row => row.slice(n));
        }

        // Display missing value counts in a table
        function showMissingValues() {
            if (!parsedData) return;
            const headers = parsedData.headers;
            const rows = currentRows;
            missingValuesDiv.innerHTML = '';
            const table = document.createElement('table');
            const thead = document.createElement('thead');
            const hr = document.createElement('tr');
            ['Column', 'Missing Count', 'Missing %'].forEach(txt => {
                const th = document.createElement('th');
                th.textContent = txt;
                hr.appendChild(th);
            });
            thead.appendChild(hr);
            table.appendChild(thead);
            const tbody = document.createElement('tbody');
            headers.forEach(h => {
                let missing = 0;
                rows.forEach(r => {
                    const val = r[h];
                    if (val === null || val === undefined || val === '') missing++;
                });
                const percent = rows.length > 0 ? ((missing / rows.length) * 100).toFixed(1) : '0.0';
                const tr = document.createElement('tr');
                [h, String(missing), percent + '%'].forEach(txt => {
                    const td = document.createElement('td');
                    td.textContent = txt;
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
            table.appendChild(tbody);
            const caption = document.createElement('p');
            caption.textContent = 'Missing values summary';
            missingValuesDiv.appendChild(caption);
            missingValuesDiv.appendChild(table);
        }

        // Recompute numeric and categorical columns based on currentRows
        function recomputeColumns() {
            if (!parsedData) return;
            numericCols = [];
            categoricalCols = [];
            parsedData.headers.forEach(h => {
                const values = currentRows.map(r => r[h]);
                if (isNumericColumn(values)) {
                    numericCols.push(h);
                } else {
                    categoricalCols.push(h);
                }
            });
            // Update target select dropdown
            const previous = targetSelect.value;
            targetSelect.innerHTML = '<option value="">(none)</option>';
            numericCols.forEach(col => {
                const opt = document.createElement('option');
                opt.value = col;
                opt.textContent = col;
                targetSelect.appendChild(opt);
            });
            if (previous && numericCols.includes(previous)) {
                targetSelect.value = previous;
            }
            targetContainer.style.display = numericCols.length > 0 ? 'block' : 'none';
        }

        // Apply selected missing value strategy
        function applyMissingStrategy() {
            if (!parsedData) return;
            const strategy = missingStrategySelect.value;
            if (strategy === 'none') {
                showMissingValues();
                return;
            }
            // Build replacement values if imputation is selected
            const headers = parsedData.headers;
            const replacements = {};
            if (strategy === 'mean' || strategy === 'median') {
                headers.forEach(h => {
                    const values = currentRows.map(r => r[h]);
                    if (isNumericColumn(values)) {
                        const nums = values.map(v => parseFloat(v)).filter(v => !isNaN(v));
                        if (nums.length > 0) {
                            if (strategy === 'mean') {
                                const mean = nums.reduce((a, b) => a + b, 0) / nums.length;
                                replacements[h] = mean;
                            } else {
                                const sorted = nums.slice().sort((a,b) => a - b);
                                const median = sorted[Math.floor(nums.length / 2)];
                                replacements[h] = median;
                            }
                        }
                    } else {
                        // mode for categorical
                        const freq = {};
                        values.forEach(v => {
                            if (v !== null && v !== undefined && v !== '') {
                                freq[v] = (freq[v] || 0) + 1;
                            }
                        });
                        let bestVal = null;
                        let bestCount = -1;
                        Object.keys(freq).forEach(v => {
                            if (freq[v] > bestCount) { bestCount = freq[v]; bestVal = v; }
                        });
                        replacements[h] = bestVal;
                    }
                });
            }
            // Apply strategy
            // Capture the number of rows before applying the missing value strategy.  This allows
            // us to compute how many rows are removed when dropping missing values.  We do this
            // before we build the newRows array and reassign currentRows.
            const originalCount = currentRows.length;
            const newRows = [];
            currentRows.forEach(row => {
                let include = true;
                const newRow = Object.assign({}, row);
                headers.forEach(h => {
                    const val = newRow[h];
                    if (val === null || val === undefined || val === '') {
                        if (strategy === 'drop') {
                            include = false;
                        } else if (strategy === 'mean' || strategy === 'median') {
                            // replace missing with precomputed replacement if available
                            if (replacements[h] !== undefined) {
                                newRow[h] = replacements[h];
                            }
                        }
                    }
                });
                if (include) newRows.push(newRow);
            });
            currentRows = newRows;
            // Log missing value handling
            let detailsMsg = '';
            if (strategy === 'drop') {
                // Compute how many rows were removed using originalCount captured before cleaning.
                const removed = originalCount - newRows.length;
                detailsMsg = `Dropped rows with missing values; removed ${removed} rows; ${newRows.length} remain`;
            } else if (strategy === 'mean' || strategy === 'median') {
                detailsMsg = `Imputed missing values using ${strategy}; dataset now has ${newRows.length} rows`;
            }
            if (detailsMsg) addHistory('Missing values', detailsMsg);
            recomputeColumns();
            // Re-run analysis with last inputs
            displayResults(lastHypothesis, lastScope);
            showMissingValues();
        }

        // Remove outliers based on z-score threshold
        function removeOutliers() {
            if (!parsedData || numericCols.length === 0) return;
            const threshold = parseFloat(zThresholdInput.value) || 3;
            const means = {};
            const stds = {};
            numericCols.forEach(col => {
                const nums = currentRows.map(r => parseFloat(r[col])).filter(v => !isNaN(v));
                const stats = computeStats(nums);
                means[col] = stats.mean;
                stds[col] = stats.std;
            });
            const newRows = [];
            currentRows.forEach(row => {
                let outlier = false;
                numericCols.forEach(col => {
                    const v = parseFloat(row[col]);
                    if (!isNaN(v) && stds[col] > 0) {
                        const z = (v - means[col]) / stds[col];
                        if (Math.abs(z) > threshold) {
                            outlier = true;
                        }
                    }
                });
                if (!outlier) newRows.push(Object.assign({}, row));
            });
            currentRows = newRows;
            // Log outlier removal
            addHistory('Outliers', `Removed outliers using z-score threshold ${threshold}; dataset now has ${newRows.length} rows`);
            recomputeColumns();
            displayResults(lastHypothesis, lastScope);
            showMissingValues();
        }

        // Update modeling options based on algorithm selection
        function updateModelOptions() {
            modelOptions.innerHTML = '';
            modelResultsDiv.innerHTML = '';
            const alg = modelSelect.value;
            if (alg === 'knn') {
                const label = document.createElement('label');
                label.textContent = 'k (neighbors):';
                label.setAttribute('for', 'knnK');
                label.title = 'Number of neighbors for K‑NN algorithm';
                const input = document.createElement('input');
                input.type = 'number';
                input.id = 'knnK';
                input.min = '1';
                input.max = '20';
                input.value = '5';
                input.title = 'Choose how many nearest neighbors to use for classification/regression.';
                modelOptions.appendChild(label);
                modelOptions.appendChild(input);
            } else if (alg === 'kmeans') {
                const label = document.createElement('label');
                label.textContent = 'Number of clusters:';
                label.setAttribute('for', 'kMeansK');
                label.title = 'Number of clusters for K‑means clustering';
                const input = document.createElement('input');
                input.type = 'number';
                input.id = 'kMeansK';
                input.min = '2';
                input.max = '10';
                input.value = '3';
                input.title = 'Specify how many clusters to form when running K‑means.';
                modelOptions.appendChild(label);
                modelOptions.appendChild(input);
            } else if (alg === 'decisionTree') {
                // Decision tree options: max depth and min samples per node
                const labelD1 = document.createElement('label');
                labelD1.textContent = 'Max depth:';
                labelD1.setAttribute('for', 'treeDepth');
                labelD1.title = 'Maximum depth of the decision tree (controls model complexity)';
                const inputD1 = document.createElement('input');
                inputD1.type = 'number';
                inputD1.id = 'treeDepth';
                inputD1.min = '1';
                inputD1.max = '10';
                inputD1.value = '3';
                inputD1.title = 'Set the maximum number of levels the decision tree may grow to.';
                const labelD2 = document.createElement('label');
                labelD2.textContent = 'Min samples per node:';
                labelD2.setAttribute('for', 'treeMinSamples');
                labelD2.title = 'Minimum samples required at a node to split (affects overfitting)';
                const inputD2 = document.createElement('input');
                inputD2.type = 'number';
                inputD2.id = 'treeMinSamples';
                inputD2.min = '1';
                inputD2.max = '20';
                inputD2.value = '5';
                inputD2.title = 'Specify the minimum number of samples to allow a split in the tree.';
                modelOptions.appendChild(labelD1);
                modelOptions.appendChild(inputD1);
                modelOptions.appendChild(labelD2);
                modelOptions.appendChild(inputD2);
            }
        }

        // Run selected model
        function runModel() {
            modelResultsDiv.innerHTML = '';
            const alg = modelSelect.value;
            if (!alg) return;
            if (alg === 'linear') {
                runLinearModel();
            } else if (alg === 'logistic') {
                runLogisticModel();
            } else if (alg === 'knn') {
                runKNNModel();
            } else if (alg === 'kmeans') {
                runKMeansModel();
            } else if (alg === 'decisionTree') {
                runDecisionTreeModel();
            }
        }

        // Linear regression with train/test split and metrics
        function runLinearModel() {
            const target = targetSelect.value;
            if (!target) {
                alert('Please select a target variable for linear regression.');
                return;
            }
            if (!numericCols.includes(target)) {
                alert('Target variable must be numeric for linear regression.');
                return;
            }
            const predictors = numericCols.filter(c => c !== target);
            if (predictors.length === 0) {
                alert('No numeric predictors available for linear regression.');
                return;
            }
            // Prepare shuffled copy of currentRows and determine CV folds
            const cvInput = document.getElementById('cvFolds');
            const cvFolds = cvInput ? parseInt(cvInput.value) : 1;
            const rows = currentRows.slice();
            for (let i = rows.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [rows[i], rows[j]] = [rows[j], rows[i]];
            }
            // Determine scaling method and precompute stats for predictors
            const scalingMethod = scalingSelect ? scalingSelect.value : 'none';
            const scalingStats = computeScalingStats(predictors);
            let crossMetrics = null;
            if (cvFolds && cvFolds > 1) {
                const foldSize = Math.floor(rows.length / cvFolds);
                let totalR2 = 0;
                let totalMSE = 0;
                for (let fold = 0; fold < cvFolds; fold++) {
                    const testStart = fold * foldSize;
                    const testEnd = (fold === cvFolds - 1) ? rows.length : testStart + foldSize;
                    const testRowsCV = rows.slice(testStart, testEnd);
                    const trainRowsCV = rows.slice(0, testStart).concat(rows.slice(testEnd));
                    // Build matrices with scaled predictors
                    const X_train_CV = trainRowsCV.map(r => scalePredictorValues(r, predictors, scalingStats, scalingMethod));
                    const y_train_CV = trainRowsCV.map(r => parseFloat(r[target]) || 0);
                    X_train_CV.forEach((row, idx) => { X_train_CV[idx] = [1, ...row]; });
                    // Compute coefficients
                    const XT_CV = transposeMatrix(X_train_CV);
                    const XTX_CV = multiplyMatrices(XT_CV, X_train_CV);
                    const inv_CV = invertMatrix(XTX_CV);
                    if (!inv_CV) continue;
                    const XTy_CV = multiplyMatrices(XT_CV, y_train_CV.map(v => [v]));
                    const betaMat_CV = multiplyMatrices(inv_CV, XTy_CV);
                    const betaCV = betaMat_CV.map(row => row[0]);
                    // Evaluate on test
                    const X_test_CV = testRowsCV.map(r => scalePredictorValues(r, predictors, scalingStats, scalingMethod));
                    const y_test_CV = testRowsCV.map(r => parseFloat(r[target]) || 0);
                    X_test_CV.forEach((row, idx) => { X_test_CV[idx] = [1, ...row]; });
                    const y_pred_CV = X_test_CV.map(row => {
                        let val = 0;
                        for (let j = 0; j < row.length; j++) {
                            val += row[j] * betaCV[j];
                        }
                        return val;
                    });
                    let sseCV = 0;
                    let sstCV = 0;
                    const meanCV = y_test_CV.reduce((a,b) => a + b, 0) / (y_test_CV.length || 1);
                    for (let i2 = 0; i2 < y_test_CV.length; i2++) {
                        const diff = y_test_CV[i2] - y_pred_CV[i2];
                        sseCV += diff * diff;
                        const diffMean = y_test_CV[i2] - meanCV;
                        sstCV += diffMean * diffMean;
                    }
                    const mseCV = y_test_CV.length > 0 ? sseCV / y_test_CV.length : 0;
                    const r2CV = sstCV > 0 ? 1 - (sseCV / sstCV) : 0;
                    totalR2 += r2CV;
                    totalMSE += mseCV;
                }
                crossMetrics = {
                    r2: totalR2 / cvFolds,
                    mse: totalMSE / cvFolds
                };
            }
            const trainSize = (cvFolds && cvFolds > 1) ? rows.length : Math.max(1, Math.floor(rows.length * 0.8));
            const trainRows = rows.slice(0, trainSize);
            const testRows = rows.slice(trainSize);
            // Construct X and y for training with scaling
            const X_train = trainRows.map(r => scalePredictorValues(r, predictors, scalingStats, scalingMethod));
            const y_train = trainRows.map(r => parseFloat(r[target]) || 0);
            X_train.forEach((row, idx) => { X_train[idx] = [1, ...row]; });
            // Compute coefficients using normal equation
            const XT = transposeMatrix(X_train);
            const XTX = multiplyMatrices(XT, X_train);
            const inv = invertMatrix(XTX);
            if (!inv) {
                modelResultsDiv.innerHTML = 'Unable to compute linear regression coefficients (singular matrix).';
                return;
            }
            const XTy = multiplyMatrices(XT, y_train.map(v => [v]));
            const betaMat = multiplyMatrices(inv, XTy);
            const beta = betaMat.map(row => row[0]);
            // Evaluate on test set
            const X_test = testRows.map(r => scalePredictorValues(r, predictors, scalingStats, scalingMethod));
            const y_test = testRows.map(r => parseFloat(r[target]) || 0);
            X_test.forEach((row, idx) => { X_test[idx] = [1, ...row]; });
            const y_pred = X_test.map(row => {
                let val = 0;
                for (let j = 0; j < row.length; j++) {
                    val += row[j] * beta[j];
                }
                return val;
            });
            // Compute metrics
            const n = y_test.length;
            let sse = 0;
            let sst = 0;
            const meanY = y_test.reduce((a,b) => a + b, 0) / (n || 1);
            for (let i = 0; i < n; i++) {
                const diff = y_test[i] - y_pred[i];
                sse += diff * diff;
                const diffMean = y_test[i] - meanY;
                sst += diffMean * diffMean;
            }
            const mse = n > 0 ? sse / n : 0;
            const r2 = sst > 0 ? 1 - (sse / sst) : 0;
            // Display results
            let html = '';
            html += `<strong>Linear Regression</strong> (target: ${target})<br/>`;
            html += `Intercept: ${beta[0].toFixed(4)}<br/>`;
            predictors.forEach((p, idx) => {
                html += `Coefficient for ${p}: ${beta[idx + 1].toFixed(4)}<br/>`;
            });
            html += '<br/><em>Model performance (test set):</em><br/>';
            html += `R² = ${r2.toFixed(3)}, MSE = ${mse.toFixed(3)}<br/>`;
            if (crossMetrics) {
                html += `<br/><em>Cross‑validation (${cvFolds}-fold) average performance:</em><br/>`;
                html += `R² = ${crossMetrics.r2.toFixed(3)}, MSE = ${crossMetrics.mse.toFixed(3)}<br/>`;
            }
            modelResultsDiv.innerHTML = html;
            // Log the linear regression run
            try {
                const detailMsg = `Linear regression on ${target} with predictors ${predictors.join(', ')}; R²=${r2.toFixed(3)}, MSE=${mse.toFixed(3)}${crossMetrics ? ', CV R²=' + crossMetrics.r2.toFixed(3) + ', CV MSE=' + crossMetrics.mse.toFixed(3) : ''}`;
                addHistory('Model', detailMsg);
            } catch (ex) {
                // ignore logging errors
            }
        }

        // Logistic regression with train/test split and classification metrics
        function runLogisticModel() {
            const target = targetSelect.value;
            if (!target) {
                alert('Please select a binary target variable for logistic regression.');
                return;
            }
            // Determine unique values of target
            const targetValues = currentRows.map(r => r[target]);
            const uniqueVals = Array.from(new Set(targetValues.map(v => String(v))));
            if (uniqueVals.length !== 2) {
                alert('Target variable must have exactly two unique values for logistic regression.');
                return;
            }
            const mapping = {};
            mapping[uniqueVals[0]] = 0;
            mapping[uniqueVals[1]] = 1;
            const predictors = numericCols.filter(c => c !== target);
            if (predictors.length === 0) {
                alert('No numeric predictors available for logistic regression.');
                return;
            }
            // Determine CV folds and shuffle data
            const cvInput = document.getElementById('cvFolds');
            const cvFolds = cvInput ? parseInt(cvInput.value) : 1;
            const rows = currentRows.slice();
            for (let i = rows.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [rows[i], rows[j]] = [rows[j], rows[i]];
            }
            let crossMetrics = null;
            // Determine feature scaling method and precompute stats
            const scalingMethod = scalingSelect ? scalingSelect.value : 'none';
            const scalingStats = computeScalingStats(predictors);
            if (cvFolds && cvFolds > 1) {
                const foldSize = Math.floor(rows.length / cvFolds);
                let totalAcc = 0, totalPrec = 0, totalRec = 0, totalF1 = 0;
                for (let fold = 0; fold < cvFolds; fold++) {
                    const testStart = fold * foldSize;
                    const testEnd = (fold === cvFolds - 1) ? rows.length : testStart + foldSize;
                    const testRowsCV = rows.slice(testStart, testEnd);
                    const trainRowsCV = rows.slice(0, testStart).concat(rows.slice(testEnd));
                    // Build training matrices with scaled predictors
                    const X_train_CV = trainRowsCV.map(r => scalePredictorValues(r, predictors, scalingStats, scalingMethod));
                    const y_train_CV = trainRowsCV.map(r => mapping[String(r[target])]);
                    X_train_CV.forEach((row, idx) => { X_train_CV[idx] = [1, ...row]; });
                    let betaCV = new Array(X_train_CV[0].length).fill(0);
                    const iterationsCV = 200;
                    const lrCV = 0.01;
                    for (let iter = 0; iter < iterationsCV; iter++) {
                        const gradients = new Array(betaCV.length).fill(0);
                        for (let i2 = 0; i2 < X_train_CV.length; i2++) {
                            let z = 0;
                            for (let j = 0; j < betaCV.length; j++) z += X_train_CV[i2][j] * betaCV[j];
                            const pred = 1 / (1 + Math.exp(-z));
                            const err = y_train_CV[i2] - pred;
                            for (let j = 0; j < betaCV.length; j++) gradients[j] += err * X_train_CV[i2][j];
                        }
                        for (let j = 0; j < betaCV.length; j++) betaCV[j] += lrCV * gradients[j];
                    }
                    // Evaluate on test
                    const X_test_CV = testRowsCV.map(r => scalePredictorValues(r, predictors, scalingStats, scalingMethod));
                    const y_test_CV = testRowsCV.map(r => mapping[String(r[target])]);
                    X_test_CV.forEach((row, idx) => { X_test_CV[idx] = [1, ...row]; });
                    const probsCV = X_test_CV.map(row => {
                        let z = 0;
                        for (let j = 0; j < row.length; j++) z += row[j] * betaCV[j];
                        return 1 / (1 + Math.exp(-z));
                    });
                    const predsCV = probsCV.map(p => (p >= 0.5 ? 1 : 0));
                    let tpCV = 0, tnCV = 0, fpCV = 0, fnCV = 0;
                    for (let i2 = 0; i2 < predsCV.length; i2++) {
                        if (predsCV[i2] === 1 && y_test_CV[i2] === 1) tpCV++;
                        else if (predsCV[i2] === 0 && y_test_CV[i2] === 0) tnCV++;
                        else if (predsCV[i2] === 1 && y_test_CV[i2] === 0) fpCV++;
                        else if (predsCV[i2] === 0 && y_test_CV[i2] === 1) fnCV++;
                    }
                    const acc = (tpCV + tnCV) / (tpCV + tnCV + fpCV + fnCV || 1);
                    const prec = tpCV + fpCV > 0 ? tpCV / (tpCV + fpCV) : 0;
                    const rec = tpCV + fnCV > 0 ? tpCV / (tpCV + fnCV) : 0;
                    const f1CV = prec + rec > 0 ? (2 * prec * rec) / (prec + rec) : 0;
                    totalAcc += acc;
                    totalPrec += prec;
                    totalRec += rec;
                    totalF1 += f1CV;
                }
                crossMetrics = {
                    accuracy: totalAcc / cvFolds,
                    precision: totalPrec / cvFolds,
                    recall: totalRec / cvFolds,
                    f1: totalF1 / cvFolds
                };
            }
            const trainSize = (cvFolds && cvFolds > 1) ? rows.length : Math.max(1, Math.floor(rows.length * 0.8));
            const trainRows = rows.slice(0, trainSize);
            const testRows = rows.slice(trainSize);
            const X_train = trainRows.map(r => scalePredictorValues(r, predictors, scalingStats, scalingMethod));
            const y_train = trainRows.map(r => mapping[String(r[target])]);
            X_train.forEach((row, idx) => { X_train[idx] = [1, ...row]; });
            // Initialize beta
            const pDim = X_train[0].length;
            let beta = new Array(pDim).fill(0);
            const iterations = 300;
            const lr = 0.01;
            // Gradient descent
            for (let iter = 0; iter < iterations; iter++) {
                const gradients = new Array(pDim).fill(0);
                for (let i = 0; i < X_train.length; i++) {
                    let z = 0;
                    for (let j = 0; j < pDim; j++) z += X_train[i][j] * beta[j];
                    const pred = 1 / (1 + Math.exp(-z));
                    const err = y_train[i] - pred;
                    for (let j = 0; j < pDim; j++) gradients[j] += err * X_train[i][j];
                }
                for (let j = 0; j < pDim; j++) beta[j] += lr * gradients[j];
            }
            // Evaluate on test set
            const X_test = testRows.map(r => scalePredictorValues(r, predictors, scalingStats, scalingMethod));
            const y_test = testRows.map(r => mapping[String(r[target])]);
            X_test.forEach((row, idx) => { X_test[idx] = [1, ...row]; });
            const probs = X_test.map(row => {
                let z = 0;
                for (let j = 0; j < row.length; j++) z += row[j] * beta[j];
                return 1 / (1 + Math.exp(-z));
            });
            const preds = probs.map(p => (p >= 0.5 ? 1 : 0));
            // Compute confusion matrix and metrics
            let tp = 0, tn = 0, fp = 0, fn = 0;
            for (let i = 0; i < preds.length; i++) {
                if (preds[i] === 1 && y_test[i] === 1) tp++;
                else if (preds[i] === 0 && y_test[i] === 0) tn++;
                else if (preds[i] === 1 && y_test[i] === 0) fp++;
                else if (preds[i] === 0 && y_test[i] === 1) fn++;
            }
            const accuracy = (tp + tn) / (tp + tn + fp + fn || 1);
            const precision = tp + fp > 0 ? tp / (tp + fp) : 0;
            const recall = tp + fn > 0 ? tp / (tp + fn) : 0;
            const f1 = precision + recall > 0 ? (2 * precision * recall) / (precision + recall) : 0;
            // Compute pseudo-R² (McFadden) on the test set
            let pseudoR2 = null;
            if (y_test && probs && y_test.length === probs.length && y_test.length > 0) {
                // Compute log-likelihood for full model
                let llFull = 0;
                let llNull = 0;
                // Compute constant probability (intercept-only) as proportion of positive class
                const posCount = y_test.reduce((acc, v) => acc + (v === 1 ? 1 : 0), 0);
                const p0 = posCount / y_test.length;
                // Avoid log(0) by clipping probabilities
                const clip = (v) => Math.min(0.999999, Math.max(0.000001, v));
                for (let i = 0; i < y_test.length; i++) {
                    const yi = y_test[i];
                    const pi = clip(probs[i]);
                    llFull += yi * Math.log(pi) + (1 - yi) * Math.log(1 - pi);
                    const pi0 = clip(p0);
                    llNull += yi * Math.log(pi0) + (1 - yi) * Math.log(1 - pi0);
                }
                // McFadden pseudo-R²: 1 - LL_full / LL_null
                if (llNull !== 0) {
                    pseudoR2 = 1 - (llFull / llNull);
                }
            }
            // Display results
            let html = '';
            html += `<strong>Logistic Regression</strong> (target: ${target})<br/>`;
            html += `Intercept: ${beta[0].toFixed(4)}<br/>`;
            predictors.forEach((p, idx) => {
                html += `Coefficient for ${p}: ${beta[idx + 1].toFixed(4)}<br/>`;
            });
            html += '<br/><em>Model performance (test set):</em><br/>';
            html += `Accuracy = ${accuracy.toFixed(3)}, Precision = ${precision.toFixed(3)}, Recall = ${recall.toFixed(3)}, F1 = ${f1.toFixed(3)}<br/>`;
            if (crossMetrics) {
                html += `<br/><em>Cross‑validation (${cvFolds}-fold) average performance:</em><br/>`;
                html += `Accuracy = ${crossMetrics.accuracy.toFixed(3)}, Precision = ${crossMetrics.precision.toFixed(3)}, Recall = ${crossMetrics.recall.toFixed(3)}, F1 = ${crossMetrics.f1.toFixed(3)}<br/>`;
            }
            if (pseudoR2 !== null) {
                html += `<br/>Pseudo‑R² (McFadden) = ${pseudoR2.toFixed(3)}<br/>`;
            }
            html += `<br/>Confusion matrix:<br/>`;
            html += `TP: ${tp}, TN: ${tn}, FP: ${fp}, FN: ${fn}`;
            modelResultsDiv.innerHTML = html;
            // Log logistic regression run
            try {
                const detailMsg = `Logistic regression on ${target} with predictors ${predictors.join(', ')}; Accuracy=${accuracy.toFixed(3)}, Precision=${precision.toFixed(3)}, Recall=${recall.toFixed(3)}, F1=${f1.toFixed(3)}${crossMetrics ? ', CV Acc=' + crossMetrics.accuracy.toFixed(3) : ''}`;
                addHistory('Model', detailMsg);
            } catch (ex) {
                // ignore
            }
        }

        // K-Nearest Neighbors classification/regression
        function runKNNModel() {
            const target = targetSelect.value;
            if (!target) {
                alert('Please select a target variable for KNN.');
                return;
            }
            const kInput = document.getElementById('knnK');
            const k = kInput ? parseInt(kInput.value) : 5;
            if (!k || k < 1) {
                alert('Invalid value of k.');
                return;
            }
            // Determine if target is numeric or categorical
            const isNumericTarget = numericCols.includes(target);
            // Define predictors: numeric and categorical (excluding target)
            const numPredictors = numericCols.filter(c => c !== target);
            const catPredictors = categoricalCols.filter(c => c !== target);
            // Create mappings for categorical predictors to integer codes
            const catMappings = {};
            catPredictors.forEach(c => {
                const uniq = Array.from(new Set(currentRows.map(r => r[c])));
                const map = {};
                uniq.forEach((val, idx) => { map[val] = idx; });
                catMappings[c] = map;
            });
            // Determine scaling method and compute stats for numeric predictors
            const scalingMethod = scalingSelect ? scalingSelect.value : 'none';
            const statsNum = computeScalingStats(numPredictors);
            function featureVector(row) {
                const arr = [];
                // Apply scaling to numeric predictors
                numPredictors.forEach((p, idx) => {
                    let val = parseFloat(row[p]);
                    if (isNaN(val)) val = 0;
                    // scaling
                    if (scalingMethod === 'standard') {
                        const std = statsNum.stds[idx] || 1;
                        val = (val - statsNum.means[idx]) / std;
                    } else if (scalingMethod === 'minmax') {
                        const range = statsNum.maxs[idx] - statsNum.mins[idx];
                        val = range !== 0 ? (val - statsNum.mins[idx]) / range : 0;
                    }
                    arr.push(val);
                });
                // Append encoded categorical predictors (no scaling)
                catPredictors.forEach(p => {
                    const map = catMappings[p];
                    const val = row[p];
                    arr.push(map[val] !== undefined ? map[val] : 0);
                });
                return arr;
            }
            // Prepare dataset with features and labels
            const data = currentRows.map(row => {
                return {
                    features: featureVector(row),
                    label: row[target]
                };
            });
            // Shuffle
            for (let i = data.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [data[i], data[j]] = [data[j], data[i]];
            }
            const trainSize = Math.max(1, Math.floor(data.length * 0.8));
            const trainData = data.slice(0, trainSize);
            const testData = data.slice(trainSize);
            // Distance function
            function distance(a, b) {
                let sum = 0;
                for (let i = 0; i < a.length; i++) {
                    const d = a[i] - b[i];
                    sum += d * d;
                }
                return Math.sqrt(sum);
            }
            // Predictions
            let totalErr = 0;
            let correct = 0;
            const yActual = [];
            const yPred = [];
            testData.forEach(testRow => {
                // compute distances
                const dists = trainData.map(trainRow => {
                    return { dist: distance(testRow.features, trainRow.features), label: trainRow.label };
                });
                dists.sort((a, b) => a.dist - b.dist);
                const neighbors = dists.slice(0, k);
                if (isNumericTarget) {
                    // regression: average of neighbor labels
                    const vals = neighbors.map(n => parseFloat(n.label) || 0);
                    const predVal = vals.reduce((a,b) => a + b, 0) / vals.length;
                    yActual.push(parseFloat(testRow.label) || 0);
                    yPred.push(predVal);
                } else {
                    // classification: majority vote
                    const freq = {};
                    neighbors.forEach(n => {
                        freq[n.label] = (freq[n.label] || 0) + 1;
                    });
                    let bestLabel = null;
                    let bestCount = -1;
                    Object.keys(freq).forEach(l => {
                        if (freq[l] > bestCount) { bestCount = freq[l]; bestLabel = l; }
                    });
                    yActual.push(testRow.label);
                    yPred.push(bestLabel);
                }
            });
            let html = '';
            if (isNumericTarget) {
                // compute regression metrics
                let mse = 0;
                let mae = 0;
                for (let i = 0; i < yActual.length; i++) {
                    const diff = yActual[i] - yPred[i];
                    mse += diff * diff;
                    mae += Math.abs(diff);
                }
                mse = yActual.length > 0 ? mse / yActual.length : 0;
                mae = yActual.length > 0 ? mae / yActual.length : 0;
                html += `<strong>KNN Regression</strong> (k=${k}, target: ${target})<br/>`;
                html += `MSE = ${mse.toFixed(3)}, MAE = ${mae.toFixed(3)}<br/>`;
            } else {
                // compute classification accuracy
                let correctCount = 0;
                for (let i = 0; i < yActual.length; i++) {
                    if (yActual[i] === yPred[i]) correctCount++;
                }
                const accuracy = yActual.length > 0 ? correctCount / yActual.length : 0;
                html += `<strong>KNN Classification</strong> (k=${k}, target: ${target})<br/>`;
                html += `Accuracy = ${accuracy.toFixed(3)}<br/>`;
            }
            modelResultsDiv.innerHTML = html;
            // Log KNN model run
            try {
                if (isNumericTarget) {
                    addHistory('Model', `KNN regression (k=${k}) on ${target}; MSE=${mse.toFixed(3)}, MAE=${mae.toFixed(3)}`);
                } else {
                    addHistory('Model', `KNN classification (k=${k}) on ${target}; Accuracy=${accuracy.toFixed(3)}`);
                }
            } catch (ex) {
                // ignore
            }
        }

        // K-means clustering on numeric features
        function runKMeansModel() {
            // Determine numeric features
            const kInput = document.getElementById('kMeansK');
            const k = kInput ? parseInt(kInput.value) : 3;
            if (!k || k < 2) {
                alert('Number of clusters must be at least 2.');
                return;
            }
            if (numericCols.length < 1) {
                alert('No numeric columns available for K-means clustering.');
                return;
            }
            // Determine scaling method and compute stats for numeric columns
            const scalingMethod = scalingSelect ? scalingSelect.value : 'none';
            const statsKM = computeScalingStats(numericCols);
            // Prepare data: use numeric columns as features, applying scaling if selected
            const features = currentRows.map(row => {
                return numericCols.map((col, idx) => {
                    let val = parseFloat(row[col]);
                    if (isNaN(val)) val = 0;
                    if (scalingMethod === 'standard') {
                        const std = statsKM.stds[idx] || 1;
                        return (val - statsKM.means[idx]) / std;
                    } else if (scalingMethod === 'minmax') {
                        const range = statsKM.maxs[idx] - statsKM.mins[idx];
                        return range !== 0 ? (val - statsKM.mins[idx]) / range : 0;
                    } else {
                        return val;
                    }
                });
            });
            const n = features.length;
            const dim = numericCols.length;
            // Initialize centroids: random selection of k points
            const indices = [];
            while (indices.length < k) {
                const idx = Math.floor(Math.random() * n);
                if (!indices.includes(idx)) indices.push(idx);
            }
            let centroids = indices.map(idx => features[idx].slice());
            let assignments = new Array(n).fill(0);
            // K-means iterations
            const maxIter = 10;
            for (let iter = 0; iter < maxIter; iter++) {
                // Assign points to nearest centroid
                for (let i = 0; i < n; i++) {
                    let best = 0;
                    let bestDist = Infinity;
                    for (let c = 0; c < k; c++) {
                        let dist = 0;
                        for (let d = 0; d < dim; d++) {
                            const diff = features[i][d] - centroids[c][d];
                            dist += diff * diff;
                        }
                        if (dist < bestDist) {
                            bestDist = dist;
                            best = c;
                        }
                    }
                    assignments[i] = best;
                }
                // Update centroids
                const newCentroids = new Array(k).fill(0).map(() => new Array(dim).fill(0));
                const counts = new Array(k).fill(0);
                for (let i = 0; i < n; i++) {
                    const cluster = assignments[i];
                    counts[cluster]++;
                    for (let d = 0; d < dim; d++) {
                        newCentroids[cluster][d] += features[i][d];
                    }
                }
                for (let c = 0; c < k; c++) {
                    if (counts[c] > 0) {
                        for (let d = 0; d < dim; d++) {
                            newCentroids[c][d] /= counts[c];
                        }
                    } else {
                        // Reinitialize empty cluster randomly
                        const idx = Math.floor(Math.random() * n);
                        newCentroids[c] = features[idx].slice();
                        counts[c] = 1;
                    }
                }
                centroids = newCentroids;
            }
            // Build summary
            const summary = [];
            for (let c = 0; c < k; c++) {
                summary[c] = { size: 0, means: {}, modes: {} };
            }
            // Precompute modes for categorical columns within clusters
            categoricalCols.forEach(col => {
                summary.forEach(s => { s.modes[col] = {}; });
            });
            for (let i = 0; i < n; i++) {
                const cluster = assignments[i];
                summary[cluster].size++;
                numericCols.forEach((col, idx) => {
                    const v = parseFloat(currentRows[i][col]) || 0;
                    summary[cluster].means[col] = (summary[cluster].means[col] || 0) + v;
                });
                categoricalCols.forEach(col => {
                    const v = currentRows[i][col];
                    summary[cluster].modes[col][v] = (summary[cluster].modes[col][v] || 0) + 1;
                });
            }
            summary.forEach(s => {
                // finalize means
                numericCols.forEach(col => {
                    if (s.size > 0) {
                        s.means[col] = s.means[col] / s.size;
                    }
                });
                // finalize modes
                categoricalCols.forEach(col => {
                    let bestVal = null;
                    let bestCount = -1;
                    Object.keys(s.modes[col]).forEach(v => {
                        if (s.modes[col][v] > bestCount) {
                            bestCount = s.modes[col][v];
                            bestVal = v;
                        }
                    });
                    s.modes[col] = bestVal;
                });
            });
            // Display results
            let html = '';
            html += `<strong>K-means Clustering</strong> (k=${k})<br/>`;
            summary.forEach((s, idx) => {
                html += `<br/>Cluster ${idx} (size: ${s.size}):<br/>`;
                html += '<em>Numeric means:</em><br/>';
                numericCols.forEach(col => {
                    html += `${col}: ${s.means[col] !== undefined ? s.means[col].toFixed(2) : 'N/A'}<br/>`;
                });
                if (categoricalCols.length > 0) {
                    html += '<em>Most common categories:</em><br/>';
                    categoricalCols.forEach(col => {
                        html += `${col}: ${s.modes[col] !== undefined ? s.modes[col] : 'N/A'}<br/>`;
                    });
                }
            });
            modelResultsDiv.innerHTML = html;
            // Log K-means run
            try {
                addHistory('Model', `K-means clustering (k=${k}) on numeric columns; produced ${summary.length} clusters`);
            } catch (ex) {
                // ignore
            }
        }

        // Decision tree model for regression or classification with optional cross‑validation
        function runDecisionTreeModel() {
            const target = targetSelect.value;
            if (!target) {
                alert('Please select a target variable for the decision tree.');
                return;
            }
            // Determine if target is numeric or categorical
            const targetValues = currentRows.map(r => r[target]);
            let isNumericTarget = true;
            let numericCount = 0;
            targetValues.forEach(v => {
                const num = parseFloat(v);
                if (!isNaN(num)) numericCount++; else isNumericTarget = false;
            });
            // decide classification if not numeric or if only a few unique values (< 10) and numericCount < 90%
            const uniqueTargetVals = Array.from(new Set(targetValues.map(v => String(v))));
            let isClassification = false;
            if (!isNumericTarget || uniqueTargetVals.length <= 10) {
                isClassification = true;
            }
            // Determine predictors: use all numeric and categorical columns excluding target
            const predictors = parsedData.headers.filter(h => h !== target);
            if (predictors.length === 0) {
                alert('No predictors available for decision tree.');
                return;
            }
            // Separate numeric and categorical predictors
            const numPredictors = [];
            const catPredictors = [];
            predictors.forEach(p => {
                const values = currentRows.map(r => r[p]);
                if (isNumericColumn(values)) {
                    numPredictors.push(p);
                } else {
                    catPredictors.push(p);
                }
            });
            const allPredictors = numPredictors.concat(catPredictors);
            if (allPredictors.length === 0) {
                alert('No valid predictors for decision tree.');
                return;
            }
            // Encode categorical predictors to numeric codes
            const catMappings = {};
            catPredictors.forEach(c => {
                const uniq = Array.from(new Set(currentRows.map(r => r[c])));
                const map = {};
                uniq.forEach((val, idx) => { map[val] = idx; });
                catMappings[c] = map;
            });
            function encodeFeatures(row) {
                const arr = [];
                numPredictors.forEach(p => {
                    const v = parseFloat(row[p]);
                    arr.push(!isNaN(v) ? v : 0);
                });
                catPredictors.forEach(p => {
                    const map = catMappings[p];
                    const val = row[p];
                    arr.push(map[val] !== undefined ? map[val] : 0);
                });
                return arr;
            }
            // Optional feature scaling (note: scaling does not affect decision tree splits but may improve interpretability)
            const scalingMethod = scalingSelect ? scalingSelect.value : 'none';
            const stats = computeScalingStats(numPredictors); // compute only for numeric predictors
            function scaleDT(valuesArr) {
                // scale numeric predictors only; categorical encoded values remain unchanged
                const scaled = [];
                let idxNum = 0;
                let idxCat = 0;
                numPredictors.forEach((p, j) => {
                    let val = valuesArr[j];
                    if (scalingMethod === 'standard') {
                        const std = stats.stds[j] || 1;
                        val = (val - stats.means[j]) / std;
                    } else if (scalingMethod === 'minmax') {
                        const range = stats.maxs[j] - stats.mins[j];
                        val = range !== 0 ? (val - stats.mins[j]) / range : 0;
                    }
                    scaled.push(val);
                });
                // Append categorical predictors (already numeric codes)
                catPredictors.forEach(() => {
                    const idx = numPredictors.length + idxCat;
                    scaled.push(valuesArr[idx]);
                    idxCat++;
                });
                return scaled;
            }
            // Build dataset with features and labels
            const data = currentRows.map(row => {
                const featuresRaw = encodeFeatures(row);
                const features = scaleDT(featuresRaw);
                const label = isClassification ? String(row[target]) : parseFloat(row[target]);
                return { features, label };
            });
            // Shuffle data
            for (let i = data.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [data[i], data[j]] = [data[j], data[i]];
            }
            // Parameters: tree depth and min samples
            const depthInput = document.getElementById('treeDepth');
            const minSamplesInput = document.getElementById('treeMinSamples');
            const maxDepth = depthInput ? parseInt(depthInput.value) : 3;
            const minSamples = minSamplesInput ? parseInt(minSamplesInput.value) : 5;
            // Build tree recursively
            function buildTree(dataset, depth) {
                // Determine if leaf
                const labels = dataset.map(d => d.label);
                const n = labels.length;
                // For classification: check if pure or small or at max depth
                const uniqueLabels = Array.from(new Set(labels));
                if (n <= minSamples || depth >= maxDepth || uniqueLabels.length === 1) {
                    // Leaf node: return most common label or mean
                    if (isClassification) {
                        const freq = {};
                        labels.forEach(l => { freq[l] = (freq[l] || 0) + 1; });
                        let bestLabel = null;
                        let bestCount = -1;
                        Object.keys(freq).forEach(l => {
                            if (freq[l] > bestCount) { bestCount = freq[l]; bestLabel = l; }
                        });
                        return { value: bestLabel };
                    } else {
                        const sum = labels.reduce((a, b) => a + b, 0);
                        return { value: sum / (labels.length || 1) };
                    }
                }
                // Evaluate splits for each feature using a single threshold (median)
                let bestFeature = -1;
                let bestThreshold = 0;
                let bestScore = Infinity;
                let bestLeft = null;
                let bestRight = null;
                const numFeatures = dataset[0].features.length;
                for (let f = 0; f < numFeatures; f++) {
                    // extract values for feature f
                    const vals = dataset.map(d => d.features[f]);
                    // compute median as candidate threshold
                    const sortedVals = vals.slice().sort((a, b) => a - b);
                    const midIndex = Math.floor(sortedVals.length / 2);
                    const thr = (sortedVals[midIndex] + (midIndex > 0 ? sortedVals[midIndex - 1] : sortedVals[midIndex])) / 2;
                    const left = [];
                    const right = [];
                    dataset.forEach(d => {
                        if (d.features[f] <= thr) left.push(d); else right.push(d);
                    });
                    if (left.length === 0 || right.length === 0) continue;
                    let score;
                    if (isClassification) {
                        // Gini impurity
                        function gini(subset) {
                            const freq = {};
                            subset.forEach(d => { freq[d.label] = (freq[d.label] || 0) + 1; });
                            const total = subset.length;
                            let sumP2 = 0;
                            Object.values(freq).forEach(c => {
                                const p = c / total;
                                sumP2 += p * p;
                            });
                            return 1 - sumP2;
                        }
                        const gLeft = gini(left);
                        const gRight = gini(right);
                        score = (left.length / n) * gLeft + (right.length / n) * gRight;
                    } else {
                        // Regression: variance reduction (mean squared error)
                        function mse(subset) {
                            const m = subset.reduce((a, b) => a + b.label, 0) / subset.length;
                            let sse = 0;
                            subset.forEach(d => {
                                const diff = d.label - m;
                                sse += diff * diff;
                            });
                            return sse / subset.length;
                        }
                        const mseLeft = mse(left);
                        const mseRight = mse(right);
                        score = (left.length / n) * mseLeft + (right.length / n) * mseRight;
                    }
                    if (score < bestScore) {
                        bestScore = score;
                        bestFeature = f;
                        bestThreshold = thr;
                        bestLeft = left;
                        bestRight = right;
                    }
                }
                if (bestFeature === -1) {
                    // Could not split; make leaf
                    if (isClassification) {
                        const freq = {};
                        labels.forEach(l => { freq[l] = (freq[l] || 0) + 1; });
                        let bestLabel = null;
                        let bestCount = -1;
                        Object.keys(freq).forEach(l => {
                            if (freq[l] > bestCount) { bestCount = freq[l]; bestLabel = l; }
                        });
                        return { value: bestLabel };
                    } else {
                        const sum = labels.reduce((a, b) => a + b, 0);
                        return { value: sum / (labels.length || 1) };
                    }
                }
                return {
                    feature: bestFeature,
                    threshold: bestThreshold,
                    left: buildTree(bestLeft, depth + 1),
                    right: buildTree(bestRight, depth + 1)
                };
            }
            // Prediction function
            function predictTree(node, featArr) {
                if (node.value !== undefined) return node.value;
                if (featArr[node.feature] <= node.threshold) {
                    return predictTree(node.left, featArr);
                } else {
                    return predictTree(node.right, featArr);
                }
            }
            // Cross-validation
            const cvInput = document.getElementById('cvFolds');
            const cvFolds = cvInput ? parseInt(cvInput.value) : 1;
            let crossMetrics = null;
            if (cvFolds && cvFolds > 1) {
                const foldSize = Math.floor(data.length / cvFolds);
                let totalAcc = 0;
                let totalR2 = 0;
                let totalMSE = 0;
                for (let fold = 0; fold < cvFolds; fold++) {
                    const testStart = fold * foldSize;
                    const testEnd = (fold === cvFolds - 1) ? data.length : testStart + foldSize;
                    const testData = data.slice(testStart, testEnd);
                    const trainData = data.slice(0, testStart).concat(data.slice(testEnd));
                    const treeCV = buildTree(trainData, 0);
                    if (isClassification) {
                        let correct = 0;
                        testData.forEach(d => {
                            const pred = predictTree(treeCV, d.features);
                            if (pred === d.label) correct++;
                        });
                        totalAcc += (testData.length > 0 ? correct / testData.length : 0);
                    } else {
                        const actuals = testData.map(d => d.label);
                        const preds = testData.map(d => predictTree(treeCV, d.features));
                        let sse = 0;
                        let sst = 0;
                        const meanVal = actuals.reduce((a,b) => a + b, 0) / (actuals.length || 1);
                        for (let i = 0; i < actuals.length; i++) {
                            const diff = actuals[i] - preds[i];
                            sse += diff * diff;
                            const diffMean = actuals[i] - meanVal;
                            sst += diffMean * diffMean;
                        }
                        const mseCV = actuals.length > 0 ? sse / actuals.length : 0;
                        const r2CV = sst > 0 ? 1 - (sse / sst) : 0;
                        totalMSE += mseCV;
                        totalR2 += r2CV;
                    }
                }
                if (isClassification) {
                    crossMetrics = { accuracy: totalAcc / cvFolds };
                } else {
                    crossMetrics = { r2: totalR2 / cvFolds, mse: totalMSE / cvFolds };
                }
            }
            // Train final model and evaluate on hold-out set (80/20 if cvFolds==1; if cross-validation used, train on full data)
            const trainSize = (cvFolds && cvFolds > 1) ? data.length : Math.max(1, Math.floor(data.length * 0.8));
            const trainData = data.slice(0, trainSize);
            const testData = data.slice(trainSize);
            const tree = buildTree(trainData, 0);
            let html = '';
            html += `<strong>Decision Tree</strong> (target: ${target})<br/>`;
            html += `Type: ${isClassification ? 'Classification' : 'Regression'}<br/>`;
            // Generate a simple summary of the tree structure (first few splits)
            function summarize(node, depth) {
                if (!node || node.value !== undefined || depth > 2) return '';
                let text = `${'&nbsp;'.repeat(depth * 4)}Split on feature <strong>${allPredictors[node.feature]}</strong> at threshold ${node.threshold.toFixed(3)}<br/>`;
                text += summarize(node.left, depth + 1);
                text += summarize(node.right, depth + 1);
                return text;
            }
            html += `<em>Tree structure (first splits):</em><br/>`;
            html += summarize(tree, 0);
            // Evaluate on test
            if (testData.length > 0) {
                if (isClassification) {
                    let correct = 0;
                    testData.forEach(d => {
                        const pred = predictTree(tree, d.features);
                        if (pred === d.label) correct++;
                    });
                    const acc = correct / testData.length;
                    html += `<em>Model performance (test set):</em><br/>Accuracy = ${acc.toFixed(3)}<br/>`;
                } else {
                    const actuals = testData.map(d => d.label);
                    const preds = testData.map(d => predictTree(tree, d.features));
                    let sse = 0;
                    let sst = 0;
                    const meanVal = actuals.reduce((a,b) => a + b, 0) / (actuals.length || 1);
                    for (let i = 0; i < actuals.length; i++) {
                        const diff = actuals[i] - preds[i];
                        sse += diff * diff;
                        const diffMean = actuals[i] - meanVal;
                        sst += diffMean * diffMean;
                    }
                    const mse = actuals.length > 0 ? sse / actuals.length : 0;
                    const r2 = sst > 0 ? 1 - (sse / sst) : 0;
                    html += `<em>Model performance (test set):</em><br/>R² = ${r2.toFixed(3)}, MSE = ${mse.toFixed(3)}<br/>`;
                }
            }
            if (crossMetrics) {
                if (isClassification) {
                    html += `<br/><em>Cross‑validation (${cvFolds}-fold) average performance:</em><br/>Accuracy = ${crossMetrics.accuracy.toFixed(3)}<br/>`;
                } else {
                    html += `<br/><em>Cross‑validation (${cvFolds}-fold) average performance:</em><br/>R² = ${crossMetrics.r2.toFixed(3)}, MSE = ${crossMetrics.mse.toFixed(3)}<br/>`;
                }
            }
            modelResultsDiv.innerHTML = html;
            // Log decision tree run
            try {
                if (isClassification) {
                    const performance = (crossMetrics && crossMetrics.accuracy !== undefined) ? `Accuracy=${(crossMetrics.accuracy || acc || 0).toFixed(3)}` : '';
                    addHistory('Model', `Decision tree classification on ${target}; ${performance}`);
                } else {
                    const perf = (crossMetrics && crossMetrics.r2 !== undefined) ? `R²=${crossMetrics.r2.toFixed(3)}, MSE=${crossMetrics.mse.toFixed(3)}` : '';
                    addHistory('Model', `Decision tree regression on ${target}; ${perf}`);
                }
            } catch (ex) {
                // ignore
            }
        }

        // Attach cleaning and modeling event listeners
        applyCleaningBtn.addEventListener('click', applyMissingStrategy);
        removeOutliersBtn.addEventListener('click', removeOutliers);
        modelSelect.addEventListener('change', updateModelOptions);
        runModelBtn.addEventListener('click', runModel);
        // Attach duplicates and statistical test listeners
        const removeDupBtn = document.getElementById('removeDuplicatesBtn');
        if (removeDupBtn) removeDupBtn.addEventListener('click', removeDuplicates);
        const runTestBtnElem = document.getElementById('runTestBtn');
        if (runTestBtnElem) runTestBtnElem.addEventListener('click', runStatisticalTest);

        // Changelog toggle handler: allows user to show or hide the changelog on demand
        const changelogToggle = document.getElementById('toggleChangelog');
        if (changelogToggle) {
            changelogToggle.addEventListener('click', function () {
                const logDiv = document.getElementById('changelog');
                if (!logDiv) return;
                const currentlyHidden = logDiv.style.display === '' || logDiv.style.display === 'none';
                logDiv.style.display = currentlyHidden ? 'block' : 'none';
                this.textContent = currentlyHidden ? 'Hide Changelog' : 'Show Changelog';
            });
        }
        const downloadCleanBtn = document.getElementById('downloadCleanedBtn');
        if (downloadCleanBtn) downloadCleanBtn.addEventListener('click', downloadCleanedDataset);

        // Attach history download button
        const downloadHistBtn = document.getElementById('downloadHistoryBtn');
        if (downloadHistBtn) downloadHistBtn.addEventListener('click', downloadHistory);

        // Attach change listener for test type to update variable options
        const testTypeElem = document.getElementById('testTypeSelect');
        if (testTypeElem) testTypeElem.addEventListener('change', updateTestOptions);

        // End of additional utilities

        // Download report handler
        document.getElementById('downloadReportBtn').addEventListener('click', function() {
            const text = document.getElementById('reportArea').value;
            const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'analysis_report.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // =========================
        // Additional diagnostics and tests
        // =========================

        // Compute duplicates: identify duplicate rows by stringifying each row
        function computeDuplicates() {
            if (!currentRows) return { count: 0, indices: [] };
            const seen = {};
            const duplicates = [];
            currentRows.forEach((row, idx) => {
                const key = JSON.stringify(row);
                if (seen[key] !== undefined) {
                    duplicates.push(idx);
                } else {
                    seen[key] = idx;
                }
            });
            return { count: duplicates.length, indices: duplicates };
        }

        // Show duplicates summary in the diagnostics section
        function showDuplicates() {
            const dupSec = document.getElementById('duplicates-section');
            const summaryP = document.getElementById('duplicates-summary');
            if (!dupSec || !summaryP) return;
            const dup = computeDuplicates();
            if (dup.count > 0) {
                dupSec.style.display = 'block';
                summaryP.textContent = `Found ${dup.count} duplicate rows.`;
            } else {
                dupSec.style.display = 'none';
                summaryP.textContent = '';
            }
        }

        // Remove duplicates from currentRows and re-run analysis
        function removeDuplicates() {
            const dup = computeDuplicates();
            if (dup.count === 0) return;
            const indicesSet = new Set(dup.indices);
            const newRows = [];
            currentRows.forEach((row, idx) => {
                if (!indicesSet.has(idx)) {
                    newRows.push(Object.assign({}, row));
                }
            });
            currentRows = newRows;
            recomputeColumns();
            displayResults(lastHypothesis, lastScope);
            showMissingValues();
            showDuplicates();
            // Log duplicates removal
            addHistory('Duplicates', `Removed ${dup.count} duplicate rows; dataset now has ${currentRows.length} rows`);
        }

        // Download the cleaned (current) dataset as CSV
        function downloadCleanedDataset() {
            if (!parsedData || !currentRows) return;
            let csv = parsedData.headers.join(',') + '\n';
            currentRows.forEach(row => {
                const line = parsedData.headers.map(h => {
                    const v = row[h];
                    // Escape quotes and commas
                    if (v === null || v === undefined) return '';
                    const str = v.toString();
                    if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                        return '"' + str.replace(/"/g, '""') + '"';
                    } else {
                        return str;
                    }
                }).join(',');
                csv += line + '\n';
            });
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'cleaned_dataset.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            // Log export action
            addHistory('Export', `Exported cleaned dataset with ${currentRows.length} rows`);
        }

        // Update test options based on selected test type and available columns
        function updateTestOptions() {
            if (!parsedData) return;
            const testTypeElem = document.getElementById('testTypeSelect');
            if (!testTypeElem) return;
            const diffOpts = document.getElementById('diff-test-opts');
            const corrOpts = document.getElementById('corr-test-opts');
            const chiOpts = document.getElementById('chi-test-opts');
            const testType = testTypeElem.value;
            // Populate selects
            // Difference test selects: numeric variable 1 and categorical variable 1
            const numSel1 = document.getElementById('testNumericSelect1');
            const catSel1 = document.getElementById('testCategoricalSelect1');
            const numSel2 = document.getElementById('testNumericSelect2');
            const numSel3 = document.getElementById('testNumericSelect3');
            const catSel2 = document.getElementById('testCategoricalSelect2');
            const catSel3 = document.getElementById('testCategoricalSelect3');
            // Clear all selects
            [numSel1, catSel1, numSel2, numSel3, catSel2, catSel3].forEach(sel => {
                if (sel) sel.innerHTML = '';
            });
            // Populate numeric selects
            numericCols.forEach(col => {
                const opt1 = document.createElement('option');
                opt1.value = col;
                opt1.textContent = col;
                if (numSel1) numSel1.appendChild(opt1.cloneNode(true));
                if (numSel2) numSel2.appendChild(opt1.cloneNode(true));
                if (numSel3) numSel3.appendChild(opt1.cloneNode(true));
            });
            // Populate categorical selects
            categoricalCols.forEach(col => {
                const opt1 = document.createElement('option');
                opt1.value = col;
                opt1.textContent = col;
                if (catSel1) catSel1.appendChild(opt1.cloneNode(true));
                if (catSel2) catSel2.appendChild(opt1.cloneNode(true));
                if (catSel3) catSel3.appendChild(opt1.cloneNode(true));
            });
            // Show/hide option groups based on test type
            if (testType === 'difference' || testType === 'nonparam') {
                // Difference and non‑parametric tests both require one numeric and one categorical variable
                if (diffOpts) diffOpts.style.display = 'block';
                if (corrOpts) corrOpts.style.display = 'none';
                if (chiOpts) chiOpts.style.display = 'none';
            } else if (testType === 'correlation') {
                if (diffOpts) diffOpts.style.display = 'none';
                if (corrOpts) corrOpts.style.display = 'block';
                if (chiOpts) chiOpts.style.display = 'none';
            } else if (testType === 'chi2') {
                if (diffOpts) diffOpts.style.display = 'none';
                if (corrOpts) corrOpts.style.display = 'none';
                if (chiOpts) chiOpts.style.display = 'block';
            }
        }

        // Error function approximation for normal distribution
        function erf(x) {
            // Abramowitz and Stegun approximation
            const sign = (x >= 0) ? 1 : -1;
            x = Math.abs(x);
            const a1 = 0.254829592;
            const a2 = -0.284496736;
            const a3 = 1.421413741;
            const a4 = -1.453152027;
            const a5 = 1.061405429;
            const p = 0.3275911;
            const t = 1 / (1 + p * x);
            const y = 1 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
            return sign * y;
        }

        // Run statistical test based on selected type
        function runStatisticalTest() {
            const testTypeElem = document.getElementById('testTypeSelect');
            if (!testTypeElem) return;
            const testType = testTypeElem.value;
            const resultDiv = document.getElementById('testResults');
            if (!resultDiv) return;
            let resultHtml = '';
            let logMsg = '';
            if (testType === 'difference') {
                // Difference test (t-test/ANOVA)
                const numVar = document.getElementById('testNumericSelect1').value;
                const catVar = document.getElementById('testCategoricalSelect1').value;
                if (!numVar || !catVar) {
                    alert('Please select both numeric and categorical variables for the difference test.');
                    return;
                }
                // Build groups
                const groupVals = {};
                currentRows.forEach(r => {
                    const c = r[catVar];
                    const v = parseFloat(r[numVar]);
                    if (!isNaN(v)) {
                        if (!groupVals[c]) groupVals[c] = [];
                        groupVals[c].push(v);
                    }
                });
                const groups = Object.values(groupVals);
                const labels = Object.keys(groupVals);
                if (groups.length < 2) {
                    resultDiv.innerHTML = 'Not enough categories for difference test.';
                    return;
                }
                // Compute means and sample sizes
                const means = groups.map(g => g.reduce((a,b)=>a+b,0) / g.length);
                const ns = groups.map(g => g.length);
                // Compute pooled variance
                let ssWithin = 0;
                let totalN = 0;
                groups.forEach((g, idx) => {
                    const mean = means[idx];
                    g.forEach(val => { ssWithin += Math.pow(val - mean, 2); });
                    totalN += g.length;
                });
                const dfWithin = totalN - groups.length;
                const pooledVar = ssWithin / (dfWithin || 1);
                let stat = 0;
                let pValue = 0;
                if (groups.length === 2) {
                    // t-test for difference of two means
                    const diff = means[0] - means[1];
                    const se = Math.sqrt(pooledVar / ns[0] + pooledVar / ns[1]);
                    const t = diff / (se || 1);
                    // approximate p-value using normal distribution
                    const z = Math.abs(t);
                    const p = 2 * (1 - 0.5 * (1 + erf(z / Math.sqrt(2))));
                    stat = t;
                    pValue = p;
                    resultHtml += `<strong>T-test</strong> for ${numVar} by ${catVar}<br/>`;
                    resultHtml += `t-statistic = ${t.toFixed(3)}, p ≈ ${p.toFixed(4)}<br/>`;
                    // Compute 95% confidence interval for the difference of means
                    const ciLow = diff - 1.96 * (se || 0);
                    const ciHigh = diff + 1.96 * (se || 0);
                    resultHtml += `95% CI for mean difference = [` + ciLow.toFixed(3) + `, ` + ciHigh.toFixed(3) + `]<br/>`;
                    // Compute effect size (Cohen's d) using pooled standard deviation
                    const pooledSD = Math.sqrt(pooledVar);
                    const d = (pooledSD > 0) ? (diff / pooledSD) : 0;
                    resultHtml += `Effect size (Cohen's d) = ${d.toFixed(3)}<br/>`;
                    logMsg += `, d=${d.toFixed(3)}`;
                    logMsg = `T-test on ${numVar} by ${catVar}: t=${t.toFixed(3)}, p≈${p.toFixed(4)}, CI=[${ciLow.toFixed(3)},${ciHigh.toFixed(3)}]`;
                } else {
                    // ANOVA for more than two groups
                    // Between-group sum of squares
                    const overallMean = means.reduce((a,b,i) => a + b * ns[i], 0) / totalN;
                    let ssBetween = 0;
                    groups.forEach((g, idx) => {
                        ssBetween += ns[idx] * Math.pow(means[idx] - overallMean, 2);
                    });
                    const dfBetween = groups.length - 1;
                    const msBetween = ssBetween / (dfBetween || 1);
                    const msWithin = pooledVar;
                    const f = msBetween / (msWithin || 1);
                    // approximate p-value using normal distribution for F
                    // Convert F to z by Fisher's z (approx) or just use tail of chi-square distribution
                    const z = Math.sqrt(f);
                    const p = 1 - 0.5 * (1 + erf(z / Math.sqrt(2)));
                    resultHtml += `<strong>ANOVA</strong> for ${numVar} by ${catVar}<br/>`;
                    resultHtml += `F-statistic = ${f.toFixed(3)}, p ≈ ${p.toFixed(4)}<br/>`;
                    // Approximate confidence interval for the largest difference between any two group means
                    let maxIdx = 0;
                    let minIdx = 0;
                    let maxMean = means[0];
                    let minMean = means[0];
                    for (let i = 1; i < means.length; i++) {
                        if (means[i] > maxMean) { maxMean = means[i]; maxIdx = i; }
                        if (means[i] < minMean) { minMean = means[i]; minIdx = i; }
                    }
                    const diffPair = maxMean - minMean;
                    const sePair = Math.sqrt(pooledVar / ns[maxIdx] + pooledVar / ns[minIdx]);
                    const ciLowPair = diffPair - 1.96 * (sePair || 0);
                    const ciHighPair = diffPair + 1.96 * (sePair || 0);
                    resultHtml += `Largest mean difference (between ${labels[maxIdx]} and ${labels[minIdx]}) = ${diffPair.toFixed(3)}, 95% CI = [` + ciLowPair.toFixed(3) + `, ` + ciHighPair.toFixed(3) + `]<br/>`;
                    // Compute effect size (eta-squared) for ANOVA
                    const etaSq = (ssBetween + 1e-12) > 0 ? (ssBetween / (ssBetween + ssWithin)) : 0;
                    resultHtml += `Effect size (η²) = ${etaSq.toFixed(3)}<br/>`;
                    logMsg += `, eta2=${etaSq.toFixed(3)}`;
                    logMsg = `ANOVA on ${numVar} by ${catVar}: F=${f.toFixed(3)}, p≈${p.toFixed(4)}, largest diff CI=[${ciLowPair.toFixed(3)},${ciHighPair.toFixed(3)}], eta2=${etaSq.toFixed(3)}`;
                }
            } else if (testType === 'nonparam') {
                // Non‑parametric test: Mann‑Whitney U for two groups or Kruskal‑Wallis for multiple groups
                const numVar = document.getElementById('testNumericSelect1').value;
                const catVar = document.getElementById('testCategoricalSelect1').value;
                if (!numVar || !catVar) {
                    alert('Please select both numeric and categorical variables for the non‑parametric test.');
                    return;
                }
                // Build groups
                const groupValsNP = {};
                currentRows.forEach(r => {
                    const c = r[catVar];
                    const v = parseFloat(r[numVar]);
                    if (!isNaN(v)) {
                        if (!groupValsNP[c]) groupValsNP[c] = [];
                        groupValsNP[c].push(v);
                    }
                });
                const groupsNP = Object.values(groupValsNP);
                const labelsNP = Object.keys(groupValsNP);
                if (groupsNP.length < 2) {
                    resultDiv.innerHTML = 'Not enough categories for non‑parametric test.';
                    return;
                }
                // Combine values with group index for ranking
                const combined = [];
                groupsNP.forEach((g, idx) => {
                    g.forEach(val => {
                        combined.push({ value: val, group: idx });
                    });
                });
                // Sort by value
                combined.sort((a, b) => a.value - b.value);
                // Assign ranks with average for ties
                let rank = 1;
                for (let i = 0; i < combined.length; i++) {
                    let j = i;
                    while (j + 1 < combined.length && combined[j + 1].value === combined[i].value) {
                        j++;
                    }
                    const avgRank = (rank + j + 1) / 2;
                    for (let k = i; k <= j; k++) {
                        combined[k].rank = avgRank;
                    }
                    rank += (j - i + 1);
                    i = j;
                }
                // Sum ranks per group and counts
                const R = Array(groupsNP.length).fill(0);
                const n = Array(groupsNP.length).fill(0);
                combined.forEach(item => {
                    R[item.group] += item.rank;
                    n[item.group]++;
                });
                const N = combined.length;
                let p = 0;
                let statName = '';
                let statVal = 0;
                if (groupsNP.length === 2) {
                    // Mann–Whitney U test
                    const n1 = n[0];
                    const n2 = n[1];
                    const U1 = R[0] - (n1 * (n1 + 1)) / 2;
                    const U2 = R[1] - (n2 * (n2 + 1)) / 2;
                    const U = Math.min(U1, U2);
                    const meanU = (n1 * n2) / 2;
                    const varU = (n1 * n2 * (n1 + n2 + 1)) / 12;
                    const z = (U - meanU) / Math.sqrt(varU || 1);
                    p = 2 * (1 - 0.5 * (1 + erf(Math.abs(z) / Math.sqrt(2))));
                    statName = 'Mann–Whitney U';
                    statVal = U;
                    resultHtml += `<strong>Non‑parametric test</strong> (Mann–Whitney U) for ${numVar} by ${catVar}<br/>`;
                    resultHtml += `U = ${U.toFixed(3)}, p ≈ ${p.toFixed(4)}<br/>`;
                    // Effect size: rank-biserial correlation (r) = 1 - (2U)/(n1*n2)
                    const rrb = 1 - (2 * U) / (n1 * n2);
                    resultHtml += `Effect size (rank-biserial r) = ${rrb.toFixed(3)}<br/>`;
                    logMsg += `, r=${rrb.toFixed(3)}`;
                    logMsg = `Mann–Whitney U on ${numVar} by ${catVar}: U=${U.toFixed(3)}, p≈${p.toFixed(4)}, r=${rrb.toFixed(3)}`;
                } else {
                    // Kruskal–Wallis test for >2 groups
                    let H = 0;
                    for (let i = 0; i < n.length; i++) {
                        if (n[i] > 0) {
                            H += (R[i] * R[i]) / n[i];
                        }
                    }
                    H = (12 / (N * (N + 1))) * H - 3 * (N + 1);
                    const df = groupsNP.length - 1;
                    // Approximate p-value using normal approximation to chi-square distribution
                    const zH = (H - df) / Math.sqrt(2 * df);
                    p = 1 - 0.5 * (1 + erf(zH / Math.sqrt(2)));
                    statName = 'Kruskal–Wallis H';
                    statVal = H;
                    resultHtml += `<strong>Non‑parametric test</strong> (Kruskal–Wallis) for ${numVar} by ${catVar}<br/>`;
                    resultHtml += `H = ${H.toFixed(3)}, df = ${df}, p ≈ ${p.toFixed(4)}<br/>`;
                    // Effect size: epsilon-squared = (H - k + 1)/(N - k)
                    const kGrp = groupsNP.length;
                    const epsilonSq = (N > kGrp) ? ((H - (kGrp - 1)) / (N - kGrp)) : 0;
                    const epsilonSqClipped = Math.max(0, Math.min(1, epsilonSq));
                    resultHtml += `Effect size (ε²) = ${epsilonSqClipped.toFixed(3)}<br/>`;
                    logMsg += `, eps2=${epsilonSqClipped.toFixed(3)}`;
                    logMsg = `Kruskal–Wallis on ${numVar} by ${catVar}: H=${H.toFixed(3)}, df=${df}, p≈${p.toFixed(4)}, eps2=${epsilonSqClipped.toFixed(3)}`;
                }
            } else if (testType === 'correlation') {
                // Correlation test
                const var1 = document.getElementById('testNumericSelect2').value;
                const var2 = document.getElementById('testNumericSelect3').value;
                const method = document.getElementById('corrTestMethod').value;
                if (!var1 || !var2) {
                    alert('Please select two numeric variables for the correlation test.');
                    return;
                }
                // Extract numeric pairs
                const xVals = currentRows.map(r => r[var1]);
                const yVals = currentRows.map(r => r[var2]);
                let rVal = 0;
                if (method === 'spearman') {
                    rVal = computeSpearmanCorrelation(xVals, yVals);
                } else {
                    rVal = computeCorrelation(xVals, yVals);
                }
                // Compute t-statistic and approximate p-value
                const nPairs = xVals.filter((v, idx) => !isNaN(parseFloat(v)) && !isNaN(parseFloat(yVals[idx]))).length;
                const t = rVal * Math.sqrt(nPairs - 2) / Math.sqrt(1 - rVal * rVal);
                const z = Math.abs(t);
                const p = 2 * (1 - 0.5 * (1 + erf(z / Math.sqrt(2))));
                resultHtml += `<strong>Correlation</strong> (${method}) between ${var1} and ${var2}<br/>`;
                resultHtml += `r = ${rVal.toFixed(3)}, t-statistic = ${t.toFixed(3)}, p ≈ ${p.toFixed(4)}<br/>`;
                // Effect size: coefficient of determination
                const rSquared = rVal * rVal;
                resultHtml += `Effect size (r²) = ${rSquared.toFixed(3)}<br/>`;
                // Compute Fisher transformation for confidence intervals
                let ciLow = -1, ciHigh = 1;
                if (nPairs > 3 && Math.abs(rVal) < 1) {
                    const fisherZ = 0.5 * Math.log((1 + rVal) / (1 - rVal));
                    const seZ = 1 / Math.sqrt(nPairs - 3);
                    const zLow = fisherZ - 1.96 * seZ;
                    const zHigh = fisherZ + 1.96 * seZ;
                    ciLow = (Math.exp(2 * zLow) - 1) / (Math.exp(2 * zLow) + 1);
                    ciHigh = (Math.exp(2 * zHigh) - 1) / (Math.exp(2 * zHigh) + 1);
                    resultHtml += `95% CI for r = [` + ciLow.toFixed(3) + `, ` + ciHigh.toFixed(3) + `]<br/>`;
                }
                logMsg = `Correlation (${method}) between ${var1} and ${var2}: r=${rVal.toFixed(3)}, t=${t.toFixed(3)}, p≈${p.toFixed(4)}, r²=${rSquared.toFixed(3)}, CI=[${ciLow.toFixed(3)},${ciHigh.toFixed(3)}]`;
            } else if (testType === 'chi2') {
                // Chi-square test
                const varA = document.getElementById('testCategoricalSelect2').value;
                const varB = document.getElementById('testCategoricalSelect3').value;
                if (!varA || !varB) {
                    alert('Please select two categorical variables for the chi-square test.');
                    return;
                }
                // Build contingency table
                const categoriesA = Array.from(new Set(currentRows.map(r => r[varA])));
                const categoriesB = Array.from(new Set(currentRows.map(r => r[varB])));
                const table = {};
                categoriesA.forEach(a => {
                    table[a] = {};
                    categoriesB.forEach(b => { table[a][b] = 0; });
                });
                currentRows.forEach(r => {
                    const a = r[varA];
                    const b = r[varB];
                    if (table[a] && table[a][b] !== undefined) {
                        table[a][b]++;
                    }
                });
                // Compute row and column totals
                const rowTotals = {};
                const colTotals = {};
                let grandTotal = 0;
                categoriesA.forEach(a => {
                    rowTotals[a] = 0;
                    categoriesB.forEach(b => {
                        const val = table[a][b];
                        rowTotals[a] += val;
                        colTotals[b] = (colTotals[b] || 0) + val;
                        grandTotal += val;
                    });
                });
                // Compute chi-square statistic
                let chiSq = 0;
                categoriesA.forEach(a => {
                    categoriesB.forEach(b => {
                        const expected = (rowTotals[a] * colTotals[b]) / (grandTotal || 1);
                        const observed = table[a][b];
                        if (expected > 0) {
                            chiSq += Math.pow(observed - expected, 2) / expected;
                        }
                    });
                });
                const df = (categoriesA.length - 1) * (categoriesB.length - 1);
                // Approximate p-value using normal approximation to chi-square
                const z = (chiSq - df) / Math.sqrt(2 * df);
                const p = 1 - 0.5 * (1 + erf(z / Math.sqrt(2)));
                resultHtml += `<strong>Chi‑square test</strong> for independence between ${varA} and ${varB}<br/>`;
                resultHtml += `χ² = ${chiSq.toFixed(3)}, df = ${df}, p ≈ ${p.toFixed(4)}<br/>`;
                // Effect size: Cramer's V
                const rDim = categoriesA.length;
                const cDim = categoriesB.length;
                const minDim = Math.max(1, Math.min(rDim - 1, cDim - 1));
                const cramerV = (grandTotal > 0 && minDim > 0) ? Math.sqrt(chiSq / (grandTotal * minDim)) : 0;
                resultHtml += `Effect size (Cramer's V) = ${cramerV.toFixed(3)}<br/>`;
                logMsg = `Chi-square test between ${varA} and ${varB}: chi2=${chiSq.toFixed(3)}, df=${df}, p≈${p.toFixed(4)}, V=${cramerV.toFixed(3)}`;
            }
            resultDiv.innerHTML = resultHtml;
            if (logMsg) addHistory('Statistical test', logMsg);
        }
    </script>
</body>
</html>