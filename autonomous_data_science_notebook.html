<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crimson Corridor: Bojan's Club Run</title>
    <style>
        :root {
            color-scheme: dark;
            --bg: #0b0b10;
            --panel: #151522;
            --accent: #e94560;
            --accent-bright: #ff4d6d;
            --text: #f7f7fb;
            --muted: #b2b2c2;
            --good: #4cd964;
            --warning: #f5a623;
            --vip: #f7c948;
        }

        * {
            box-sizing: border-box;
            font-family: "Inter", "Segoe UI", sans-serif;
        }

        body {
            margin: 0;
            background: radial-gradient(circle at top, #1b1b2f, #0b0b10 60%);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            padding: 24px clamp(20px, 6vw, 60px);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        }

        header h1 {
            margin: 0;
            font-size: clamp(24px, 3vw, 34px);
            letter-spacing: 0.08em;
        }

        header p {
            margin: 4px 0 0;
            color: var(--muted);
            font-size: 14px;
        }

        .container {
            display: grid;
            grid-template-columns: minmax(0, 1fr) 320px;
            gap: 24px;
            padding: 24px clamp(20px, 6vw, 60px) 40px;
            flex: 1;
        }

        .panel {
            background: var(--panel);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        #game-wrap {
            position: relative;
            overflow: hidden;
            min-height: 420px;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 12px;
            background: radial-gradient(circle at 20% 20%, #1f1f36, #0a0a12 70%);
        }

        .hud {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .hud .stat {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: var(--muted);
        }

        .bar {
            position: relative;
            height: 10px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 999px;
            overflow: hidden;
        }

        .bar span {
            display: block;
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--accent-bright));
            transition: width 0.2s ease;
        }

        .bar.health span {
            background: linear-gradient(90deg, #ff4d4d, #ff915a);
        }

        .bar.stamina span {
            background: linear-gradient(90deg, #49f2c0, #3dd5f3);
        }

        .bar.rage span {
            background: linear-gradient(90deg, #ff8c42, #fcee21);
        }

        .bar.shield span {
            background: linear-gradient(90deg, #5aa9ff, #9bd4ff);
        }

        .hint {
            font-size: 13px;
            color: var(--muted);
            line-height: 1.6;
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.08);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .overlay {
            position: absolute;
            inset: 0;
            background: rgba(6, 6, 12, 0.82);
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 24px;
        }

        .overlay.hidden {
            display: none;
        }

        .overlay-card {
            background: rgba(15, 15, 26, 0.95);
            border-radius: 16px;
            padding: 24px;
            max-width: 560px;
            width: 100%;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        }

        .overlay-card h2 {
            margin-top: 0;
            font-size: 24px;
        }

        .button-row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
        }

        button {
            background: var(--accent);
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 10px;
            font-size: 14px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(233, 69, 96, 0.3);
        }

        button.secondary {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text);
        }

        .upgrade-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin-top: 16px;
        }

        .upgrade-card {
            background: rgba(255, 255, 255, 0.06);
            border-radius: 12px;
            padding: 14px;
            border: 1px solid transparent;
            text-align: left;
        }

        .upgrade-card h3 {
            margin: 0 0 6px;
            font-size: 14px;
        }

        .upgrade-card p {
            margin: 0;
            font-size: 12px;
            color: var(--muted);
            line-height: 1.4;
        }

        .story {
            background: rgba(255, 255, 255, 0.04);
            border-radius: 12px;
            padding: 14px;
            font-size: 13px;
            line-height: 1.5;
            color: var(--muted);
        }

        .story strong {
            color: var(--text);
        }

        .toast {
            position: absolute;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(22, 22, 36, 0.9);
            padding: 10px 18px;
            border-radius: 999px;
            font-size: 14px;
            color: var(--vip);
            border: 1px solid rgba(255, 255, 255, 0.12);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .toast.show {
            opacity: 1;
        }

        footer {
            padding: 16px clamp(20px, 6vw, 60px);
            color: var(--muted);
            font-size: 12px;
        }

        @media (max-width: 960px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <header>
        <div>
            <h1>Crimson Corridor: Bojan's Club Run</h1>
            <p>Slap through the crowd, earn your wristbands, and force your way into the midnight club.</p>
        </div>
        <div class="badge">Episode 1</div>
    </header>

    <main class="container">
        <section class="panel" id="game-wrap">
            <canvas id="gameCanvas" width="960" height="540" aria-label="Crimson Corridor game canvas"></canvas>
            <div class="toast" id="clubToast">Club access granted! Bonus score + heal.</div>

            <div class="overlay" id="startOverlay">
                <div class="overlay-card">
                    <h2>How Bojan Became the Serbianhero</h2>
                    <p class="hint">Bojan was once a quiet door runner in Novi Sad. One night the line-cutters stormed the club, bruising his friends and blocking the dance floor. He slapped his way through the chaos, saved the crowd, and earned the name <strong>Serbianhero</strong>. Tonight the same crew is back, and getting into the club means everything.</p>
                    <p class="hint">WASD / Arrow keys to move. Space to slap. Shift to dash. E to unleash a Super Slap when the rage meter fills. P to pause. Survive the waves and pick upgrades between outbreaks.</p>
                    <div class="button-row">
                        <button id="startButton">Start Run</button>
                        <button class="secondary" id="toggleGore">Gore: On</button>
                    </div>
                </div>
            </div>

            <div class="overlay hidden" id="upgradeOverlay">
                <div class="overlay-card">
                    <h2>Street Upgrade</h2>
                    <p class="hint">Choose one boost before the next crowd wave hits.</p>
                    <div class="upgrade-grid" id="upgradeGrid"></div>
                </div>
            </div>

            <div class="overlay hidden" id="gameOverOverlay">
                <div class="overlay-card">
                    <h2>Run Over</h2>
                    <p class="hint" id="gameOverStats"></p>
                    <div class="button-row">
                        <button id="retryButton">Run it Back</button>
                    </div>
                </div>
            </div>
        </section>

        <aside class="panel hud">
            <div class="stat"><span>Status</span><span id="statusLabel">Idle</span></div>
            <div>
                <div class="stat"><span>Health</span><span id="healthLabel">100</span></div>
                <div class="bar health"><span id="healthBar"></span></div>
            </div>
            <div>
                <div class="stat"><span>Stamina</span><span id="staminaLabel">100</span></div>
                <div class="bar stamina"><span id="staminaBar"></span></div>
            </div>
            <div>
                <div class="stat"><span>Rage</span><span id="rageLabel">0%</span></div>
                <div class="bar rage"><span id="rageBar"></span></div>
            </div>
            <div>
                <div class="stat"><span>Shield</span><span id="shieldLabel">0</span></div>
                <div class="bar shield"><span id="shieldBar"></span></div>
            </div>
            <div class="stat"><span>Wave</span><span id="waveLabel">0</span></div>
            <div class="stat"><span>Threats Remaining</span><span id="threatLabel">0</span></div>
            <div class="stat"><span>VIP Wristbands</span><span id="vipLabel">0/3</span></div>
            <div class="stat"><span>Score</span><span id="scoreLabel">0</span></div>
            <div class="stat"><span>Combo</span><span id="comboLabel">x1</span></div>
            <div class="stat"><span>High Score</span><span id="highScoreLabel">0</span></div>
            <div class="hint">
                <strong>Improvements active:</strong>
                <ul>
                    <li>Directional slap cone with readable arc.</li>
                    <li>Rage meter + Super Slap shockwave.</li>
                    <li>VIP wristbands plus club-entry bonuses.</li>
                    <li>Charger enemies with dash attacks.</li>
                    <li>Shield pickups and dash invulnerability.</li>
                </ul>
            </div>
            <div class="story">
                <strong>Story Beat:</strong> The line-cutters want to shut the club. Bojan fights through the Crimson Corridor, slapping sense into anyone who blocks the doors. Earn wristbands to prove you belong and keep the party alive.
            </div>
        </aside>
    </main>

    <footer>
        Built for fast keyboard play. Help Bojan reach the club and hold the line.
    </footer>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const startOverlay = document.getElementById("startOverlay");
        const upgradeOverlay = document.getElementById("upgradeOverlay");
        const gameOverOverlay = document.getElementById("gameOverOverlay");
        const upgradeGrid = document.getElementById("upgradeGrid");
        const statusLabel = document.getElementById("statusLabel");
        const healthLabel = document.getElementById("healthLabel");
        const staminaLabel = document.getElementById("staminaLabel");
        const rageLabel = document.getElementById("rageLabel");
        const shieldLabel = document.getElementById("shieldLabel");
        const waveLabel = document.getElementById("waveLabel");
        const threatLabel = document.getElementById("threatLabel");
        const vipLabel = document.getElementById("vipLabel");
        const scoreLabel = document.getElementById("scoreLabel");
        const comboLabel = document.getElementById("comboLabel");
        const highScoreLabel = document.getElementById("highScoreLabel");
        const healthBar = document.getElementById("healthBar");
        const staminaBar = document.getElementById("staminaBar");
        const rageBar = document.getElementById("rageBar");
        const shieldBar = document.getElementById("shieldBar");
        const gameOverStats = document.getElementById("gameOverStats");
        const startButton = document.getElementById("startButton");
        const retryButton = document.getElementById("retryButton");
        const toggleGoreButton = document.getElementById("toggleGore");
        const clubToast = document.getElementById("clubToast");

        const keys = new Set();
        let lastTime = 0;
        let goreEnabled = true;
        let gameState = "title";
        let wave = 0;
        let score = 0;
        let combo = 1;
        let comboTimer = 0;
        let highScore = Number(localStorage.getItem("crimsonHighScore") || 0);
        let rage = 0;
        const maxRage = 100;
        let vipBands = 0;
        let vipTarget = 3;
        let clubLevel = 0;
        let screenShake = 0;
        let screenShakeIntensity = 0;
        let toastTimer = 0;
        let shield = 0;
        const maxShield = 60;

        const player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 14,
            speed: 2.6,
            dashSpeed: 6,
            dashCooldown: 0,
            dashCost: 30,
            health: 100,
            maxHealth: 100,
            stamina: 100,
            maxStamina: 100,
            staminaRegen: 18,
            damage: 22,
            swingCooldown: 0,
            swingRange: 64,
            comboGrace: 1.6,
            facingX: 1,
            facingY: 0,
            invulnerable: 0,
        };

        const enemies = [];
        const particles = [];
        const splatters = [];
        const pickups = [];

        const upgrades = [
            {
                title: "Hardened Armor",
                description: "+25 max health and +10% damage reduction.",
                apply: () => {
                    player.maxHealth += 25;
                    player.health = Math.min(player.health + 25, player.maxHealth);
                    player.damageReduction = (player.damageReduction || 0) + 0.1;
                },
            },
            {
                title: "Adrenal Surge",
                description: "+0.35 move speed and +20 stamina.",
                apply: () => {
                    player.speed += 0.35;
                    player.maxStamina += 20;
                    player.stamina = Math.min(player.stamina + 20, player.maxStamina);
                },
            },
            {
                title: "Ripper Palm",
                description: "+8 slap damage and +15 slap range.",
                apply: () => {
                    player.damage += 8;
                    player.swingRange += 15;
                },
            },
            {
                title: "Pulse Injector",
                description: "+6 stamina regeneration per second.",
                apply: () => {
                    player.staminaRegen += 6;
                },
            },
            {
                title: "Dash Capacitor",
                description: "Reduce dash cooldown by 40%.",
                apply: () => {
                    player.dashCooldownReduction = (player.dashCooldownReduction || 0) + 0.4;
                },
            },
            {
                title: "Serbianhero Focus",
                description: "+0.25 combo decay grace time.",
                apply: () => {
                    player.comboGrace = (player.comboGrace || 1.6) + 0.25;
                },
            },
        ];

        function resetGame() {
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            player.health = player.maxHealth = 100;
            player.stamina = player.maxStamina = 100;
            player.speed = 2.6;
            player.damage = 22;
            player.swingRange = 64;
            player.swingCooldown = 0;
            player.staminaRegen = 18;
            player.dashCooldown = 0;
            player.dashCost = 30;
            player.damageReduction = 0;
            player.dashCooldownReduction = 0;
            player.comboGrace = 1.6;
            player.facingX = 1;
            player.facingY = 0;
            player.invulnerable = 0;
            enemies.length = 0;
            particles.length = 0;
            splatters.length = 0;
            pickups.length = 0;
            wave = 0;
            score = 0;
            combo = 1;
            comboTimer = 0;
            rage = 0;
            vipBands = 0;
            vipTarget = 3;
            clubLevel = 0;
            screenShake = 0;
            toastTimer = 0;
            shield = 0;
            clubToast.classList.remove("show");
        }

        function startGame() {
            resetGame();
            gameState = "playing";
            startOverlay.classList.add("hidden");
            gameOverOverlay.classList.add("hidden");
            statusLabel.textContent = "Engaged";
            nextWave();
        }

        function nextWave() {
            wave += 1;
            const baseCount = 4 + wave * 2;
            const eliteCount = Math.floor(wave / 3);
            const chargerCount = Math.max(0, Math.floor((wave - 1) / 4));
            spawnEnemies(baseCount, "runner");
            spawnEnemies(eliteCount, "brute");
            spawnEnemies(chargerCount, "charger");
            statusLabel.textContent = `Wave ${wave}`;
        }

        function spawnEnemies(count, type) {
            for (let i = 0; i < count; i += 1) {
                const edge = Math.floor(Math.random() * 4);
                let x = 0;
                let y = 0;
                const margin = 40;
                if (edge === 0) {
                    x = Math.random() * canvas.width;
                    y = -margin;
                } else if (edge === 1) {
                    x = canvas.width + margin;
                    y = Math.random() * canvas.height;
                } else if (edge === 2) {
                    x = Math.random() * canvas.width;
                    y = canvas.height + margin;
                } else {
                    x = -margin;
                    y = Math.random() * canvas.height;
                }
                const isBrute = type === "brute";
                const isCharger = type === "charger";
                enemies.push({
                    x,
                    y,
                    radius: isBrute ? 20 : isCharger ? 16 : 14,
                    speed: isBrute ? 1.2 + wave * 0.05 : isCharger ? 1.6 + wave * 0.04 : 1.8 + wave * 0.08,
                    health: isBrute ? 90 + wave * 12 : isCharger ? 55 + wave * 8 : 40 + wave * 6,
                    maxHealth: isBrute ? 90 + wave * 12 : isCharger ? 55 + wave * 8 : 40 + wave * 6,
                    type,
                    vx: 0,
                    vy: 0,
                    stun: 0,
                    chargeCooldown: isCharger ? 1.8 : 0,
                    charging: 0,
                });
            }
        }

        function spawnPickup(x, y, options = {}) {
            let type = options.type;
            const roll = Math.random();
            if (!type) {
                if (roll < 0.08) {
                    type = "vip";
                } else if (roll < 0.22) {
                    type = "stamina";
                } else if (roll < 0.45) {
                    type = "health";
                } else {
                    return;
                }
            }
            pickups.push({
                x,
                y,
                radius: 10,
                type,
                ttl: 14,
            });
        }

        function addSplatter(x, y) {
            if (!goreEnabled) {
                return;
            }
            splatters.push({
                x,
                y,
                radius: 12 + Math.random() * 18,
                alpha: 0.8,
            });
        }

        function addBloodBurst(x, y, color = "rgba(198, 25, 48, 0.9)") {
            if (!goreEnabled) {
                return;
            }
            for (let i = 0; i < 14; i += 1) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3.5;
                particles.push({
                    x,
                    y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 0.7 + Math.random() * 0.6,
                    size: 2 + Math.random() * 3,
                    color,
                });
            }
        }

        function addConfetti(x, y) {
            for (let i = 0; i < 18; i += 1) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                const colors = ["#f7c948", "#ff4d6d", "#3dd5f3", "#49f2c0"];
                particles.push({
                    x,
                    y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.0 + Math.random() * 0.6,
                    size: 3 + Math.random() * 3,
                    color: colors[Math.floor(Math.random() * colors.length)],
                });
            }
        }

        function addRage(amount) {
            rage = Math.min(maxRage, rage + amount);
        }

        function triggerScreenShake(intensity) {
            screenShake = 0.2;
            screenShakeIntensity = Math.max(screenShakeIntensity, intensity);
        }

        function update(delta) {
            if (gameState !== "playing") {
                return;
            }

            const deltaSeconds = delta / 1000;

            if (comboTimer > 0) {
                comboTimer -= deltaSeconds;
                if (comboTimer <= 0) {
                    combo = 1;
                }
            }

            const moveX = (keys.has("ArrowRight") || keys.has("d") ? 1 : 0) - (keys.has("ArrowLeft") || keys.has("a") ? 1 : 0);
            const moveY = (keys.has("ArrowDown") || keys.has("s") ? 1 : 0) - (keys.has("ArrowUp") || keys.has("w") ? 1 : 0);
            const magnitude = Math.hypot(moveX, moveY) || 1;
            let speed = player.speed;

            if (keys.has("Shift") && player.stamina > player.dashCost && player.dashCooldown <= 0) {
                player.stamina -= player.dashCost;
                player.dashCooldown = 1.6 * (1 - (player.dashCooldownReduction || 0));
                speed = player.dashSpeed;
                player.invulnerable = 0.25;
            }

            if (magnitude > 0.1) {
                player.facingX = moveX / magnitude;
                player.facingY = moveY / magnitude;
            }

            player.x += (moveX / magnitude) * speed;
            player.y += (moveY / magnitude) * speed;

            player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
            player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));

            if (player.swingCooldown > 0) {
                player.swingCooldown -= deltaSeconds;
            }

            if (player.dashCooldown > 0) {
                player.dashCooldown -= deltaSeconds;
            }

            if (player.invulnerable > 0) {
                player.invulnerable -= deltaSeconds;
            }

            player.stamina = Math.min(player.maxStamina, player.stamina + player.staminaRegen * deltaSeconds);

            if (keys.has(" ") && player.swingCooldown <= 0 && player.stamina >= 12) {
                player.swingCooldown = 0.35;
                player.stamina -= 12;
                performAttack(false);
            }

            if ((keys.has("e") || keys.has("E")) && rage >= maxRage && player.swingCooldown <= 0) {
                player.swingCooldown = 0.6;
                superSlap();
            }

            updateEnemies(deltaSeconds);
            updateParticles(deltaSeconds);
            updatePickups(deltaSeconds);

            if (screenShake > 0) {
                screenShake -= deltaSeconds;
                if (screenShake <= 0) {
                    screenShakeIntensity = 0;
                }
            }

            if (toastTimer > 0) {
                toastTimer -= deltaSeconds;
                if (toastTimer <= 0) {
                    clubToast.classList.remove("show");
                }
            }

            if (enemies.length === 0) {
                gameState = "upgrade";
                showUpgrades();
            }
        }

        function performAttack(isSuper) {
            const range = isSuper ? player.swingRange * 1.6 : player.swingRange;
            const damage = isSuper ? player.damage * 1.8 : player.damage;
            const coneAngle = isSuper ? Math.PI / 1.9 : Math.PI / 2.6;
            const facingX = player.facingX;
            const facingY = player.facingY;
            let hit = 0;
            enemies.forEach((enemy) => {
                const distance = Math.hypot(enemy.x - player.x, enemy.y - player.y);
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                const dist = Math.hypot(dx, dy) || 1;
                const dot = (dx / dist) * facingX + (dy / dist) * facingY;
                const withinCone = dot >= Math.cos(coneAngle / 2);
                if (distance < range + enemy.radius && withinCone) {
                    enemy.health -= damage;
                    hit += 1;
                    const knockback = isSuper ? 160 : 90;
                    enemy.vx += (dx / dist) * knockback;
                    enemy.vy += (dy / dist) * knockback;
                    if (isSuper) {
                        enemy.stun = Math.max(enemy.stun, 0.8);
                    }
                    addBloodBurst(enemy.x, enemy.y);
                    addSplatter(enemy.x, enemy.y);
                }
            });
            if (hit > 0) {
                combo = Math.min(6, combo + 0.2 * hit);
                comboTimer = player.comboGrace || 1.6;
                addRage(12 * hit);
                triggerScreenShake(isSuper ? 10 : 5);
            }
        }

        function superSlap() {
            rage = 0;
            addConfetti(player.x, player.y);
            performAttack(true);
        }

        function updateEnemies(deltaSeconds) {
            for (let i = enemies.length - 1; i >= 0; i -= 1) {
                const enemy = enemies[i];
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const dist = Math.hypot(dx, dy) || 1;

                if (enemy.stun > 0) {
                    enemy.stun -= deltaSeconds;
                } else if (enemy.type === "charger") {
                    enemy.chargeCooldown -= deltaSeconds;
                    if (enemy.charging > 0) {
                        enemy.charging -= deltaSeconds;
                    } else if (enemy.chargeCooldown <= 0) {
                        enemy.chargeCooldown = 2.2;
                        enemy.charging = 0.4;
                        enemy.vx = (dx / dist) * 380;
                        enemy.vy = (dy / dist) * 380;
                    } else {
                        enemy.x += (dx / dist) * enemy.speed;
                        enemy.y += (dy / dist) * enemy.speed;
                    }
                } else {
                    enemy.x += (dx / dist) * enemy.speed;
                    enemy.y += (dy / dist) * enemy.speed;
                }

                enemy.x += (enemy.vx || 0) * deltaSeconds;
                enemy.y += (enemy.vy || 0) * deltaSeconds;
                enemy.vx *= 0.9;
                enemy.vy *= 0.9;

                if (dist < enemy.radius + player.radius) {
                    const damage = (enemy.type === "brute" ? 16 : 10) * deltaSeconds;
                    const reduction = player.damageReduction || 0;
                    if (player.invulnerable <= 0) {
                        if (shield > 0) {
                            shield = Math.max(0, shield - damage * 14);
                        } else {
                            player.health -= damage * (1 - reduction);
                        }
                    }
                }

                if (enemy.health <= 0) {
                    enemies.splice(i, 1);
                    score += Math.floor((enemy.type === "brute" ? 80 : 45) * combo);
                    if (enemy.type === "brute" && Math.random() < 0.5) {
                        spawnPickup(enemy.x, enemy.y, { type: "vip" });
                    } else if (enemy.type === "charger" && Math.random() < 0.4) {
                        spawnPickup(enemy.x, enemy.y, { type: "shield" });
                    } else {
                        spawnPickup(enemy.x, enemy.y);
                    }
                }
            }

            if (player.health <= 0) {
                endGame();
            }
        }

        function updateParticles(deltaSeconds) {
            for (let i = particles.length - 1; i >= 0; i -= 1) {
                const particle = particles[i];
                particle.life -= deltaSeconds;
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.95;
                particle.vy *= 0.95;
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }
            for (let i = splatters.length - 1; i >= 0; i -= 1) {
                const splatter = splatters[i];
                splatter.alpha -= deltaSeconds * 0.04;
                if (splatter.alpha <= 0) {
                    splatters.splice(i, 1);
                }
            }
        }

        function clubEntryBonus() {
            clubLevel += 1;
            vipBands = 0;
            vipTarget = Math.min(6, 3 + clubLevel);
            score += 250 + clubLevel * 120;
            player.health = Math.min(player.maxHealth, player.health + 35);
            player.stamina = Math.min(player.maxStamina, player.stamina + 40);
            enemies.forEach((enemy) => {
                enemy.stun = Math.max(enemy.stun, 1.2);
            });
            addConfetti(canvas.width / 2, 80);
            clubToast.classList.add("show");
            toastTimer = 2.4;
        }

        function updatePickups(deltaSeconds) {
            for (let i = pickups.length - 1; i >= 0; i -= 1) {
                const pickup = pickups[i];
                pickup.ttl -= deltaSeconds;
                if (pickup.ttl <= 0) {
                    pickups.splice(i, 1);
                    continue;
                }
                const distance = Math.hypot(pickup.x - player.x, pickup.y - player.y);
                if (distance < pickup.radius + player.radius) {
                    if (pickup.type === "health") {
                        player.health = Math.min(player.maxHealth, player.health + 25);
                    } else if (pickup.type === "stamina") {
                        player.stamina = Math.min(player.maxStamina, player.stamina + 30);
                    } else if (pickup.type === "shield") {
                        shield = Math.min(maxShield, shield + 30);
                    } else if (pickup.type === "vip") {
                        vipBands += 1;
                        score += 60;
                        if (vipBands >= vipTarget) {
                            clubEntryBonus();
                        }
                    }
                    pickups.splice(i, 1);
                }
            }
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            if (screenShake > 0) {
                const intensity = screenShakeIntensity;
                const offsetX = (Math.random() - 0.5) * intensity;
                const offsetY = (Math.random() - 0.5) * intensity;
                ctx.translate(offsetX, offsetY);
            }

            ctx.save();
            ctx.fillStyle = "rgba(255, 255, 255, 0.04)";
            for (let x = 0; x < canvas.width; x += 40) {
                ctx.fillRect(x, 0, 1, canvas.height);
            }
            for (let y = 0; y < canvas.height; y += 40) {
                ctx.fillRect(0, y, canvas.width, 1);
            }
            ctx.restore();

            ctx.save();
            ctx.fillStyle = "rgba(247, 201, 72, 0.18)";
            ctx.fillRect(canvas.width / 2 - 80, 6, 160, 18);
            ctx.strokeStyle = "rgba(247, 201, 72, 0.6)";
            ctx.strokeRect(canvas.width / 2 - 80, 6, 160, 18);
            ctx.fillStyle = "rgba(247, 201, 72, 0.8)";
            ctx.font = "12px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("Club Door", canvas.width / 2, 19);
            ctx.restore();

            splatters.forEach((splatter) => {
                ctx.beginPath();
                ctx.fillStyle = `rgba(153, 10, 30, ${splatter.alpha})`;
                ctx.arc(splatter.x, splatter.y, splatter.radius, 0, Math.PI * 2);
                ctx.fill();
            });

            pickups.forEach((pickup) => {
                ctx.beginPath();
                let color = "rgba(255, 120, 120, 0.9)";
                if (pickup.type === "stamina") {
                    color = "rgba(80, 200, 255, 0.9)";
                }
                if (pickup.type === "shield") {
                    color = "rgba(90, 169, 255, 0.95)";
                }
                if (pickup.type === "vip") {
                    color = "rgba(247, 201, 72, 0.95)";
                }
                ctx.fillStyle = color;
                ctx.arc(pickup.x, pickup.y, pickup.radius, 0, Math.PI * 2);
                ctx.fill();
            });

            enemies.forEach((enemy) => {
                ctx.beginPath();
                ctx.fillStyle = enemy.type === "brute" ? "#8a1f2b" : "#c0293d";
                ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
                ctx.fillRect(enemy.x - enemy.radius, enemy.y - enemy.radius - 6, enemy.radius * 2, 4);
                ctx.fillStyle = "#ff4d6d";
                ctx.fillRect(enemy.x - enemy.radius, enemy.y - enemy.radius - 6, (enemy.health / enemy.maxHealth) * enemy.radius * 2, 4);
            });

            ctx.beginPath();
            ctx.fillStyle = "#f7f7fb";
            ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
            ctx.fill();

            if (player.swingCooldown > 0) {
                ctx.beginPath();
                ctx.strokeStyle = "rgba(255, 77, 109, 0.6)";
                ctx.lineWidth = 3;
                const centerAngle = Math.atan2(player.facingY, player.facingX);
                const arcSize = Math.PI / 2.6;
                ctx.arc(player.x, player.y, player.swingRange, centerAngle - arcSize / 2, centerAngle + arcSize / 2);
                ctx.stroke();
            }

            particles.forEach((particle) => {
                ctx.beginPath();
                ctx.fillStyle = particle.color || "rgba(198, 25, 48, 0.9)";
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
            ctx.font = "14px sans-serif";
            ctx.textAlign = "left";
            ctx.fillText(`Wave ${wave}`, 20, 28);
            ctx.restore();
        }

        function updateHud() {
            healthLabel.textContent = Math.ceil(player.health);
            staminaLabel.textContent = Math.ceil(player.stamina);
            rageLabel.textContent = `${Math.floor((rage / maxRage) * 100)}%`;
            shieldLabel.textContent = Math.ceil(shield);
            waveLabel.textContent = wave;
            threatLabel.textContent = enemies.length;
            vipLabel.textContent = `${vipBands}/${vipTarget}`;
            scoreLabel.textContent = score;
            comboLabel.textContent = `x${combo.toFixed(1)}`;
            highScoreLabel.textContent = highScore;
            healthBar.style.width = `${(player.health / player.maxHealth) * 100}%`;
            staminaBar.style.width = `${(player.stamina / player.maxStamina) * 100}%`;
            rageBar.style.width = `${(rage / maxRage) * 100}%`;
            shieldBar.style.width = `${(shield / maxShield) * 100}%`;
        }

        function showUpgrades() {
            upgradeGrid.innerHTML = "";
            const choices = [...upgrades].sort(() => 0.5 - Math.random()).slice(0, 3);
            choices.forEach((upgrade) => {
                const card = document.createElement("div");
                card.className = "upgrade-card";
                card.innerHTML = `<h3>${upgrade.title}</h3><p>${upgrade.description}</p>`;
                const button = document.createElement("button");
                button.textContent = "Install";
                button.addEventListener("click", () => {
                    upgrade.apply();
                    upgradeOverlay.classList.add("hidden");
                    gameState = "playing";
                    nextWave();
                });
                card.appendChild(button);
                upgradeGrid.appendChild(card);
            });
            upgradeOverlay.classList.remove("hidden");
        }

        function endGame() {
            gameState = "gameover";
            statusLabel.textContent = "Down";
            gameOverStats.textContent = `You held for ${wave} waves with a score of ${score}.`;
            if (score > highScore) {
                highScore = score;
                localStorage.setItem("crimsonHighScore", highScore);
                gameOverStats.textContent += " New personal best.";
            }
            gameOverOverlay.classList.remove("hidden");
        }

        function loop(timestamp) {
            const delta = timestamp - lastTime;
            lastTime = timestamp;
            if (gameState === "playing") {
                update(delta);
            }
            if (gameState === "paused") {
                statusLabel.textContent = "Paused";
            }
            render();
            updateHud();
            requestAnimationFrame(loop);
        }

        function togglePause() {
            if (gameState === "playing") {
                gameState = "paused";
            } else if (gameState === "paused") {
                gameState = "playing";
                statusLabel.textContent = "Engaged";
            }
        }

        window.addEventListener("keydown", (event) => {
            if (event.key === "p" || event.key === "P") {
                togglePause();
                return;
            }
            keys.add(event.key);
        });

        window.addEventListener("keyup", (event) => {
            keys.delete(event.key);
        });

        startButton.addEventListener("click", startGame);
        retryButton.addEventListener("click", startGame);
        toggleGoreButton.addEventListener("click", () => {
            goreEnabled = !goreEnabled;
            toggleGoreButton.textContent = `Gore: ${goreEnabled ? "On" : "Off"}`;
            if (!goreEnabled) {
                particles.length = 0;
                splatters.length = 0;
            }
        });

        document.addEventListener("visibilitychange", () => {
            if (document.hidden && gameState === "playing") {
                gameState = "paused";
            }
        });

        requestAnimationFrame(loop);
    </script>
</body>
</html>
